#+STARTUP: content

* List Processing
Lisp stands for “Lots of Isolated Silly Parentheses”.  Or, more prosaically,
“LISt Processing”.  Lists are contained within parentheses.  Lists are the basis
of Lisp.

** Lisp Lists
This is a Lisp list:
#+begin_src emacs-lisp
  '(rose
    violet
    daisy
    buttercup)
#+end_src

#+RESULTS:
| rose | violet | daisy | buttercup |

*** Numbers, List inside Lists
Here is another list, this time with a list inside of it:
#+begin_src emacs-lisp
  '(this list has (a list inside of it))
#+end_src

#+RESULTS:
| this | list | has | (a list inside of it) |

*** Lisp Atoms
The empty list, ‘()’, is considered both an atom and a list at the same time.
“Symbolic expressions” or, more concisely, “s-expressions”, are the printed
representation of both atoms and lists.  Also, the word “form” can be used as a
synonym for expression.

Atoms are indivisible semantic units.  Numbers and symbols are examples of
atoms.  Text betwen double quotation marks (even sentences or paragraphs) is
also an atom.  Here is an example:
#+begin_src emacs-lisp
  '(this list includes "text between quotation marks.")
#+end_src

#+RESULTS:
| this | list | includes | text between quotation marks. |

This kind of atom is called a “string” (for “string of characters”).

*** Whitespace in Lists
The amount of whitespace in a list does not matter.

In brief, a list is between parentheses, a string is between quotation marks, a
symbol looks like a word, and a number looks like a number.

** Run a Program
The Lisp interpreter will evaluate a list unless it is preceded by a quote
(‘'’).  If quoted, the list is returned as is:

#+begin_src emacs-lisp
  '(this is a quoted list)
#+end_src

#+RESULTS:
| this | is | a | quoted | list |

If unquoted, the interpreter will take the first item of the list as a function
to execute, with the remaining elements of the list taken as arguments:

#+begin_src emacs-lisp
  (+ 2 2)
#+end_src

#+RESULTS:
: 4

** Making Errors
Alternatively, if the list is not compliant with the language syntax, an error
message is returned by the GNU Emacs debugger:

#+begin_src emacs-lisp
  (this is an unquoted list)
#+end_src

This instruction will invoke the debugger, which is opened in a buffer named
*Backtrace*.  To quit the debugger, type ‘q’.  The *Backtrace* shows the series
of steps that the interpreter took to evaluate the given s-expression, from the
bottom up.  The last of these messages, at the top of the *Backtrace* buffer,
conveys the absence of an instruction registered with the symbol ‘this’; in
other words, there is no function that can be executed by this list.  Thus,
‘this’ is a ‘void-function’.

** Names & Definitions
A function may have different symbols associated to it (e.g., ‘+’ anld ‘plus’ both
can refer to the set of instructions used to add numbers).  Conversely, a symbol
can have only one function associated to it at a time.

As Emacs only has one namespace, it is customary to name symbols in a way that
identifies the function with the feature of Emacs it is associated with.  Thus,
all the names for functions related to Texinfo start with ‘texinfo-’ and those
for functions that deal with reading mail start with ‘rmail-’.

** Lisp Interpreter
The Lisp interpreter first looks to see whether there is a quote before the
list; if there is, the interpreter just returns a list.  If there is no quote,
the interpreter looks at the first element olf the list and sees whether it has a
function definition.  If it does, the interpreter carries the instructions in
the function definition.  Otherwise, the interpreter prints an error message.

*** Complications
In addition to these case scenarios, the Lisp interpreter can evaluate a symbol
that is not quoted and does not have parentheses around it.  In this case, the
interpreter will attempt to determine the symbol’s value as a “variable”.

There is also an exception for unusual functions called “special forms”.  They
are used for special tasks, like defining a function, and there are not many of
them.

As well as special forms, there are also “macros”.  A macro is a construct
defined in Lisp, which differs from a function in that it translates a Lisp
expression into another expression that is to be evaluated in place of the
original expression.

The Lisp interpreter evaluates nested lists from the inside out, i.e., first it
evaluates the innermost list (the result of which can be used in the evaluation
of the enclosing expression), up to the outermost list.

*** Bite Compiling
The Lisp interpreter is able to interpret human readable code as well as byte
compiled code.  Bite compiled code is usually stored in a file with an ‘.elc’
extension, as opposed to a ‘.el’ extension, reserved for human readable code.

** Evaluation
“To ascertain the value or amount of; to appraise”, according to ‘Webster’s New
Collegiate Dictionary’.

*** How the Interpreter Acts
Evaluating a symbolic expression most commonly causes the Lisp interpreter to
return a value and perhaps carry out a side effect; or else produce an error.

*** Evaluating Inner Lists
In nested lists, the innermost list is evaluated first and its returning value
is passed to the enclosing list.  The outer expressions are then successively
evaluated (if any), up to the outermost list:

#+begin_src emacs-lisp
  (+ 2 (+ 3 3))
#+end_src

#+RESULTS:
: 8

** Variables
In Emacs Lisp, a symbol can have a value attached to it just as it can have a
function definition attached to it.  The value of a symbol can be any expression
in Lisp, such as a symbol, number, list of string.  A symbol that has a value is
often called a “variable”.  A symbol can have both a function definition and a
value attached to it at the same time.

*** fill-column example
In order to find the value attached to a variable, one needs to evaluate its
symbol:

#+begin_src emacs-lisp
fill-column
#+end_src

#+RESULTS:
: 80

*** Void Function
Note that, in the previous example, the symbol ‘fill-column’ was evaluated by
itself, and not within the context of a list.  This is because if it were
evaluated within a list, the Lisp interpreter would attempt to find the function
definition attached to it, when ‘fill-column’ has no function definition:

#+begin_src emacs-lisp
(fill-column)
#+end_src

This expression will generate a *Backtrace* buffer stating that the symbol
‘fill-column’ is a “void function”.

*** Void Variable
In addition, evaluating a symbol that does not have a value bound to it also
generates an error message.  For instance, in the following expression:

#+begin_src emacs-lisp
(+ 2 2)
#+end_src

running the command ‘eval-last-sexp’ (‘C-x C-e’), with the cursor right after
the ‘+’, will generate a *Backtrace* buffer stating that the symbol ‘+’ is a
“void variable”.  This is because the interpreter sought to look for the value
of a variable, by virtue of the fact that the “last expression” evaluated was
the symbol ‘+’, and not a list in which the first element would then be
interpreted as a function definition.

** Arguments
In Lisp, the arguments to a function are the atoms or lists that follow the
function.  The values returned by the evaluation of these atoms or lists are
passed to the function.  Different functions require different numbers of
arguments; some functions require none at all.

*** Data types
The type of data that should be passed to a function depends on what kind of
information it uses.  For example, the ‘concat’ function links together two or
more strings of text to produce a string.  The arguments are strings:

#+begin_src emacs-lisp
  (concat "abc" "def")
#+end_src

#+RESULTS:
: abcdef

The function ‘substring’ takes two types of arguments, a string and up to two
numbers that delimit the substring to return:

#+begin_src emacs-lisp
  (substring "The quick brown fox jumped." 16 19)
#+end_src

#+RESULTS:
: fox

Note that the string passed to ‘substring’ is a single atom even though it is
made up of several words separated by spaces.

*** An Argument as the Value of a Variable or List
An argument can be a symbol that returns a value when it is evaluated.  For
example, when the symbol ‘fill-column’ by itself is evaluated, it returns a
number.  This number can be used in an addition:

#+begin_src emacs-lisp
  (+ 2 fill-column)
#+end_src

#+RESULTS:
: 82

In addition, an argument can be a list that returns a value when it is
evaluated:

#+begin_src emacs-lisp
  (concat "The " (number-to-string (+ 2 fill-column)) " red foxes.")
#+end_src

#+RESULTS:
: The 82 red foxes.

*** Variable Number of Arguments
Some functions, such as ‘concat’, ‘+’ or ‘*’, take any number of arguments:

#+begin_src emacs-lisp
  (+) ; 0
  (*) ; 1
  (+ 3) ; 3
  (* 3) ; 3
  (+ 3 4 5) ; 12
  (* 3 4 5) ; 60
#+end_src

*** Wrong Type of Argument
When a function is passed  an argument of the wrong type, the Lisp interpreter
produces an error message.  For instance, the following example:

#+begin_src emacs-lisp
  (+ 2 'hello)
#+end_src

will produce a *Backtrace* buffer stating that the argument is of the wrong
type.  More specifically, the debugger message implies that the symbol passed as
argument (the quoted symbol ‘hello’) failed the “number or marker” test (a
marker is a special object representing a buffer position).

The ‘p’ of ‘number-or-marker-p’ stands for “predicate”.  A predicate is a
function to determine if some property is true or false.  Other Lisp symbols
that end in ‘p’ include ‘zerop’, a function that tests whether its argument has
the value of zero, and ‘listp’, a function that tests whether its argument is a
list.

*** The ‘message’ function
The ‘message’ function takes a variable number of arguments and is used to post
messages in the echo aread to the user:

#+begin_src emacs-lisp
  (message "This message appears in the echo area!")
#+end_src

#+RESULTS:
: This message appears in the echo area!

The format control strings ‘%s’ and ‘%d’ in the quoted string of characters are
replaced in the returned message respectively by string and integer arguments,
in the order that they appear in the argument list passed to the function:

#+begin_src emacs-lisp
  (message "The name of this buffer is: %s." (buffer-name))
#+end_src

#+RESULTS:
: The name of this buffer is: eintr.org.

#+begin_src emacs-lisp
  (message "The value of fill-column is: %d." fill-column)
#+end_src

#+RESULTS:
: The value of fill-column is: 80.

Here are two more complex examples:

#+begin_src emacs-lisp
  (message "There are %d %s in the office!"
           (- fill-column 14) "pink elephants")
#+end_src

#+RESULTS:
: There are 66 pink elephants in the office!

#+begin_src emacs-lisp
  (message "He saw %d %s"
           (- fill-column 32)
           (concat "red "
                   (substring
                    "The quick brown foxes jumped." 16 21)
                   " leaping."))
#+end_src

#+RESULTS:
: He saw 48 red foxes leaping.

** set & setq
One way by which to “bind” a variable to a value is to use either the function
‘set’ or the function ‘setq’.  Another way is to use the special form ‘let’.

*** Using set
When evaluated, the following expression will set the value of the symbol
‘flowers’ to the list ‘'(rose violet daisy buttercup)’:

#+begin_src emacs-lisp
  (set 'flowers '(rose violet daisy buttercup))
#+end_src

#+RESULTS:
| rose | violet | daisy | buttercup |

This happens as a side effect of returning the list itself.  Once set,
evaluating the symbol flowers will return the list it was assigned:

#+begin_src emacs-lisp
  flowers
#+end_src

#+RESULTS:
| rose | violet | daisy | buttercup |

However, evaluating the quoted symbol ‘'flowers’ will return the symbol itself:

#+begin_src emacs-lisp
  'flowers
#+end_src

#+RESULTS:
: flowers

*** Using setq
The special form ‘setq’ behaves like ‘set’ except that the first argument is
quoted automatically:

#+begin_src emacs-lisp
  (setq carnivores '(lion tiger leopard))
#+end_src

#+RESULTS:
| lion | tiger | leopard |

In addition, setq allows for the binding of several symbol/value pairs within
the same expression, by having each even argument bound to the preceding odd
symbol:

#+begin_src emacs-lisp
  (setq trees '(pine fir oak maple)
        herbivores '(gazelle antelope zebra))
#+end_src

#+RESULTS:
| gazelle | antelope | zebra |

*** Counting
Here is an example that shows how to use ‘setq’ in a counter:

#+begin_src emacs-lisp
  (setq counter 0)                      ; The initializer
  (setq counter (+ counter 1))          ; The incrementer
  counter                               ; The counter
#+end_src

** Summary
+ Lisp programs are made up of expressions, which are lists or single atoms.

+ Lists are made up of zero or more atoms or inner lists, separated by
  whitespace and surrounded by parentheses.  A list can be empty.

+ Atoms are multi-character symbols, like ‘forward-paragraph’, single character
  symbols like ‘+’, strings of characters between double quotation marks, or
  numbers.

+ A number evaluates to itself.

+ A string between double quotes evaluates to itself.

+ A symbol evaluated by itself returns its value.

+ When a list is evaluated, the Lisp interpreter looks at the first symbol in
  the list and then at the function definition bound to that symbol.  Then the
  instructions in the function definition are carried out.

+ The single quote ‘'’ tells the Lisp interpreter that it should return the
  following expression as written, and not evaluate it as it would if the quote
  were not there.

+ Arguments are the information passed to a function.  The arguments to a
  function are computed by evaluating the rest of the elements of the list of
  which the function is the first element.

+ A function always retuns a value when it is evaluated (unless it gets an
  error); in addition, it may also carry out some action that is a side effect.
  In many cases, a function’s primary purpose is to create a side effect.

** Exercises
*** Exercise 1.1
Generate an error message by evaluating an appropriate symbol that is not
within parentheses.

#+begin_src emacs-lisp
symbol
#+end_src

*** Exercise 1.2
Generate an error message by evaluating an appropriate symbol that is between
parentheses.

#+begin_src emacs-lisp
  (fill-column)
#+end_src

*** Exercise 1.3
Create a counter that increments by two rather than one.

#+begin_src emacs-lisp
  (setq counter2 0)
  (setq counter2 (+ counter2 2))
  counter2
#+end_src

*** Exercise 1.4
Write an expression that prints a message in the echo area when evaluated.

#+begin_src emacs-lisp
  (message "Exercises from chapter one are completed!")
#+end_src

* Practicing Evaluation
Symbol and lists can be evaluated.  When evaluating a list, the Lisp interpreter
looks for a function definition for its first element.  The instructions of the
function definition are then carried out with the arguments provided by the
subsequent elements of the list.

** How to Evaluate
In Emacs, editing commands are executed via the evaluation of an expression, the
first element of which is a function.  For instance, typing plain text is
achieved through the evaluation of an Emacs Lisp function,
‘self-insert-command’.  Such functions are called “interactive” functions, or
“commands”.

Another way to evaluate an expression is by running the command
‘eval-last-sexp’, which can be done by positioning the cursor after a list and
typing ‘C-x C-e’.

** Buffer Names
The difference between file and buffer is illustrated by the functions
‘buffer-name’ and ‘buffer-file-name’.  While evaluating the expression
‘(buffer-name)’ returns the name of the current buffer, evaluating
‘(buffer-file-name)’ retrieves the full path-name of the file:

#+begin_src emacs-lisp
  (buffer-name) ; "eintr.org[emacs-lisp]"

  (buffer-file-name) ; "/home/gtomas/Documents/programming/emacs-lisp/org/eintr/eintr.org"
#+end_src

** Getting Buffers
The ‘buffer-name’ function returns the /name/ of the buffer; to get the buffer
/itself/, the ‘current-buffer’ function is used.  Upon evaluation of this
function, the current buffer is returned as a lisp object; this is done as a
side effect of returning a specially formatted form of the buffer’s name:

#+begin_src emacs-lisp
  (current-buffer) ; #<buffer eintr.org[emacs-lisp]>
#+end_src

A related function is ‘other-buffer’.  This returns the most recently selected
buffer (that is not visible in another window) other than the one currently in
focus:

#+begin_src emacs-lisp
  (other-buffer) ; #<buffer *eshell*>
#+end_src

** Switching Buffers
The ‘other-buffer’ function provides a buffer when it is used as an argument to
a function that requires one.  It can thus be fed to the function
‘switch-to-buffer’:

#+begin_src emacs-lisp
  (switch-to-buffer (other-buffer))
#+end_src

This will skip any buffer currently displayed.  To move to the most recent
buffer, regardless of whether the buffer is already displayed in frame, the
following expression needs to be evaluated:

#+begin_src emacs-lisp
  (switch-to-buffer (other-buffer (current-buffer) t))
#+end_src

‘set-buffer’ achieves a similar goal to ‘switch-to-buffer’, with one difference:
it does not display the buffer itself (it us thus best suited for programmatic
purposes instead).

** Buffer Size & Locations
The function ‘buffer-size’ returns the size of the current buffer (a count of
the number of characters in the buffer):

#+begin_src emacs-lisp
  (buffer-size) ; 32086
#+end_src

In Emacs, the current position of the cursor is called “point”.  The expression
‘(point)’ returns an integer corresponding to the number of characters from the
beginning of the buffer to point:

#+begin_src emacs-lisp
  (point) ; 17635
#+end_src

The function ‘point-min’ returns the value of the minimum value of point in the
current buffer (which should be one unless “narrowing” is in effect).  Likewise,
the function ‘point-max’ returns the value of the maximum permissible value of
point in the current buffer.

** Exercise
Find a file with which you are working and move towards its middle.  Find its
buffer name, file name, length, and your position in the file.

#+begin_src emacs-lisp
  (switch-to-buffer (current-buffer)) ; switch to this file
  (goto-char (/ (buffer-size) 2))     ; move to its middle
  (buffer-name) ; return the name of the buffer
  (buffer-size) ; return the size (number of characters) of the buffer
  (point)       ; return the position of the point in the file
#+end_src

* How to Write Function Definitions
A symbol that has a function definition is called a function (technically, the
definition is the function and symbol /refers/ to it).

** Primitive Functions
All functions are defined in terms of other functions, except for “primitive”
functions that are written in the C programming language.  Function definitions
are written in Emacs Lisp and use other functions a their building blocks.

** defun
A function definition has up to five parts following the symbol ‘defun’:

1. The name of the symbol to which the function definition is attached.

2. A list of the arguments that will be passed to the function.  If no arguments
   will be passed to the function, this is the empty list, ‘()’.

3. Documentation describing the function.  Although technically optional, this
   is strongly recommended.

4. Optionally, an expression to make the function interactive so that it can be
   used by typing ‘M-x’ and then the name of the function; or by typing an
   appropriate key or keychord.

5. The code that instructs the computer what to do: the “body” of the function
   definition.

The template of a function definition looks like this:

#+begin_src emacs-lisp
  (defun FUNCTION-NAME (ARGUMENTS...)
    "OPTIONAL-DOCUMENTATION..."
    (interactive ARGUMENT-PASSING-INFO) ; optional
    BODY...)
#+end_src

Here is an example of a function that multiplies its argument by seven:

#+begin_src emacs-lisp
  (defun multiply-by-seven (number)
    "Multiply NUMBER by seven."
    (* 7 number))
#+end_src

** Install a Function Definition
The process of evaluating a function definition (by running the
‘eval-last-sexp’, or typing ‘C-x C-e’ with the cursor immediately after the
definition) results in the installation of the function in Emacs’ namespace
(returning the name of the function itself).  The function can now be called
from within any expression.

*** Effect of Installation
Installing a function makes it available for use within Emacs.  The following
can now be evaluated:

#+begin_src emacs-lisp
  (multiply-by-seven 3) ; 21
#+end_src

#+RESULTS:
: 21

The documentation of a function definition can be inquired by invoking the
‘describe-function’ (‘C-h f’) command.

*** Change a Function Definition
To change or update a function definition, install the modified function
definition.  This will replace the former version in the namespace:

#+begin_src emacs-lisp
  (defun multiply-by-seven (number)     ; Second version
    "Multiply NUMBER by seven."
    (+ number number number number number number number))
#+end_src

Note that, in Lisp, everything that follows a semicolon in a line is a comment.

** Make a Function Interactive
A function is made interactive by placing a list that begins with the special
form ‘interactive’ immediately after the documentation.  A user can invoke an
interactive function by typing ‘M-x’ and then the name of the function; or by
typing the keys to which it is bound, for example, by typing ‘C-n’ for
‘next-line’ or ‘C-x h’ for ‘mark-whole-buffer’.

*** Interactive multiply-by-seven
Here is an example of an interactive version of ‘multiply-by-seven’:

#+begin_src emacs-lisp
  (defun multiply-by-seven (number)     ; Interactive version
    "Multiply NUMBER by seven."
    (interactive "p")
    (message "The result is %d" (* 7 number)))
#+end_src

Once installed, the function can now be used interactively by typing ‘C-u’ and a
number and then typing ‘M-x multiply-by-seven’ and pressing <RET>.  ‘The phrase
The result is …’ followed by the product will appear in the echo area.

An interactive function is invoked in one of two ways:

1. By typing a prefix argument that contains the number to be passed, and then
   typing ‘M-x’ and the name of the function, as with ‘C-u 3 M-x
   forward-sentence’; or,

2. By typing whatever key or keychord the function is bound to, as with ‘C-u 3
   M-e’.

Both the examples above work identically to move point forward three sentences.

A “prefix argument” is passed to an interactive function by typing the <META>
key followed by a number, for example, ‘M-3 M-e’, or by typing ‘C-u’ and then a
number, for example, ‘C-u 3 M-e’ (if you type ‘C-u’ without a number, it
defaults to 4).

*** multiply-by-seven in detail
In this function, the expression, ‘(interactive "p")’, is a list of two
elements.  The ‘"p"’ tells Emacs to pass the prefix argument to the function and
use its value for the argument of the function.

** Different Options for ‘Interactive’
Consider the function ‘zap-to-char’.  Its interactive expression is (or /was/,
at the time of the writing of the book):

#+begin_src emacs-lisp
  (interactive "p\ncZap to char: ")
#+end_src

The first part of the argument to ‘interactive’ is ‘p’, which tells Emacs to
interpret a prefix as a number to be passed to the function.  In the context of
‘zap-to-char’, the prefix is the number of specified characters to delete up
to.  Thus, if the prefix is three and the specified character is ‘x’, then the
call to the function will delete all the text up to and include the third next
‘x’.  Without a prefix, the functions deletes all the text up to and including
the specified character, but no more.

The ‘c’ tells the function the name of the character to which to delete.

The ‘interactive’ declaration is a special form of ‘C source code’ that
specifies a way of parsing arguments for interactive use of a function.  The
argument of ‘interactive’ is a string containing a code letter followed
optionally by a prompt.  To pass several arguments to the command, concatenate
the individual strings, separating them by newline characters.

Code letters available are:
+ a -- Function name: symbol with a function definition.
+ b -- Name of existing buffer.
+ B -- Name of buffer, possibly nonexistent.
+ c -- Character (no input method is used).
+ C -- Command name: symbol with interactive function definition.
+ d -- Value of point as number.  Does not do I/O.
+ D -- Directory name.
+ e -- Parameterized event (i.e., one that’s a list) that invoked this command.
  If used more than once, the Nth ‘e’ returns the Nth parameterized event.
  This skips events that are integers or symbols.
+ f -- Existing file name.
+ F -- Possibly nonexistent file name.
+ G -- Possibly nonexistent file name, defaulting to just directory name.
+ i -- Ignored, i.e. always nil.  Does not do I/O.
+ k -- Key sequence (downcase the last event if needed to get a definition).
+ K -- Key sequence to be redefined (do not downcase the last event).
+ m -- Value of mark as number.  Does not do I/O.
+ M -- Any string.  Inherits the current input method.
+ n -- Number read using minibuffer.
+ N -- Numeric prefix arg, or if none, do like code ‘n’.
+ p -- Prefix arg converted to number.  Does not do I/O.
+ P -- Prefix arg in raw form.  Does not do I/O.
+ r -- Region: point and mark as 2 numeric args, smallest first.  Does no I/O.
+ s -- Any string.  Does not inherit the current input method.
+ S -- Any symbol.
+ U -- Mouse up event discarded by a previous k or K argument.
+ v -- Variable name: symbol that is ‘custom-variable-p’.
+ x -- Lisp expression read but not evaluated.
+ X -- Lisp expression read and evaluated.
+ z -- Coding system.
+ Z -- Coding system, nil if no prefix arg.

** Install Code Permanently
Functions installed through evaluation are purged from memory upon quitting
Emacs.  In order to have code installed automatically whenever Emacs is started,
one needs to:

+ Write code into the ‘.emacs’ initialization file.  This file is automatically
  evaluated when Emacs is started and all the functions within it are installed.

+ Functions can also be written into one or more files of their own and then
  loaded via the ‘load’ function.  This causes Emacs to evaluate and thereby
  install each of the functions in the files.

+ For code that an entire site will use, it is customary to write it into a file
  called ‘site-init.el’ that is loaded when Emacs is built.  This makes the code
  available for everyone using that machine.

** let
The ‘let’ expression is a special form in Lisp that is used in most function
definitions.  ‘let’ is used to attach or bind a symbol within the scope of a function.

*** Prevent confusion
‘let’ creates a name for a “local variable” that overshadows any use of the same
name outside the ‘let’ expression.

Local variables created by a ‘let’ expression retain their value /only/ within
the ‘let’ expression itself (and within expressions called within the ‘let’
expression); the local variables have no effect outside the ‘let’ expression.

‘let’ is like a ‘setq’ that is temporary and local.  The values set by ‘let’ are
automatically undone when the ‘let’ is finished.  In Emacs Lisp, scoping is
dynamic, not lexical.

From the [[https://www.wikiwand.com/en/Scope_(computer_science)#/Lexical_scope_vs._dynamic_scope][Wikipedia]] entry on lexical scope vs. dynamic scope:

#+begin_quote
In languages with lexical scope (also called static scope), name resolution
depends on the location in the source code and the lexical context, which is
defined by where the named variable or function is defined.  In contrast, in
languages with dynamic scope the name resolution depends upon the program state
when the name is encountered which is determined by the execution context or
calling context.  In practice, with lexical scope a variable’s definition is
resolved by searching its containing block or function, then if that fails
searching the outer containing block, and so on, whereas with dynamic scope the
calling function is searched, then the function which called that calling
function, and so on, progressing up the call stack.
#+end_quote

*** Parts of let expression
A ‘let’ expression is a list of three parts.  This first part is the symbol
‘let’.  The second part is a list, called a “varlist”, each element of which is
either a symbol by itself or a two-element list, the first element of which is a
symbol.  The third part of the ‘let’ expression consists of one or more lists.

The following is a template for a ‘let’  expression:

#+begin_src emacs-lisp
  (let VARLIST BODY...)
#+end_src

The symbols in the varlist are the variables that are given initial values by
the ‘let’ special form.  Symbols by themselves are given the initial value of
‘nil’; and each symbol that is the first element of a two-element list is bound
to the value that is returned when the Lisp interpreter evaluates the second
element.

Thus, a varlist might look like this: ‘(thread (needles 3))’.  In this case, in
a ‘let’ expression, Emacs binds the symbol ‘thread’ to an initial value of
‘nil’, and binds the symbol ‘needles’ to an initial value of 3.

*** Sample let Expression
The following expression creates and gives initial values to the two variables
‘zebra’ and ‘tiger’.  The body of the ‘let’ expression is a list which calls the
‘message’ function:

#+begin_src emacs-lisp
  (let ((zebra "stripes")
        (tiger "fierce"))
    (message "One kind of animal has %s and another is %s."
             zebra tiger))
#+end_src

#+RESULTS:
: One kind of animal has stripes and another is fierce.

*** Uninitialized let Variables
If you do not bind the variables of a ‘let’ statement to specific initial
values, they will automatically be bound to an initial value of ‘nil’, as in the
following expression:

#+begin_src emacs-lisp
  (let ((birch 3)
        pine
        fir
        (oak 'some))
    (message
     "Here are %d variables with %s, %s, and %s value."
     birch pine fir oak))
#+end_src

#+RESULTS:
: Here are 3 variables with nil, nil, and some value.

** if
A third special form, in addition to ‘defun’ and ‘let’, is the conditional ‘if’.
This form is used to instruct the computer to make decisions.

*** if in more detail
An ‘if’ expression written in Lisp does not use the word “then”; the test and
the action are the second and third elements of the list whose first element is
‘if’.  Nonetheless, the test part of an ‘if’ expression is often called the
“if-part” and the second argument is often called the “then-part”.

Also, when an ‘if’ expression is written, the true-or-false-test is usually
written on the same line as the symbol ‘if’, but the action to carry out if the
test is true, the then-part, is written on the second and subsequent lines.
This makes the ‘if’ expression easier to read:

#+begin_src emacs-lisp
  (if TRUE-OR-FALSE-TEST
      ACTION-TO-CARRY-OUT-IF-TEST-IS-TRUE)
#+end_src

Here is an example:

#+begin_src emacs-lisp
  (if (> 5 4)                           ; if-part
  (message "Five is greater than four!")) ; then-part
#+end_src

#+RESULTS:
: Five is greater than four!

And a more realistic example:

#+begin_src emacs-lisp
  (defun type-of-animal (characteristic)
    "Print message in echo area depending on CHARACTERISTIC.
  If the CHARACTERISTIC is the string \"fierce\",
 then warn of a tiger."
    (if (equal characteristic "fierce")
        (message "It is a tiger!")))

  (type-of-animal "fierce")"It is a tiger!"
  (type-of-animal "striped")
#+end_src

*** type-of-animal in detail
‘if’ is a special form in ‘C source code’.

The template of and ‘if’ statement is:

#+begin_src emacs-lisp
  (if COND THEN ELSE...)
#+end_src

If COND yields non-nil, do THEN, else do ELSE...
Returns the value of THEN or the value of the last of the ELSE’s.
THEN must be one expression, but ELSE... can be zero or more expressions.
If COND yields nil, and there are no ELSE’s, the value is nil.

** else
An ‘if’ expression may have an optional third argument, called the “else-part”,
for the case when the true-or-false-test returns false.  When this happens, the
second argument or then-part of the overall ‘if’ expression is /not/ evaluated,
but the third or else-part /is/ evaluated.

In the written Lisp, the else-part is usually written to start on a line of its
own and is indented less than the then-part:

#+begin_src emacs-lisp
  (if TRUE-OR-FALSE-TEST
         ACTION-TO-CARRY-OUT-IF-THE-TEST-RETURNS-TRUE
       ACTION-TO-CARRY-OUT-IF-THE-TEST-RETURNS-FALSE)
#+end_src

Here is an example:

#+begin_src emacs-lisp
  (if (> 4 5)                        ; if-part
      (message "Four falsely greater than five!") ; then-part
      (message "Four is not greater than five!"))   ; else-part
#+end_src

#+RESULTS:
: Four is not greater than five!

And a more elaborated example with the ‘type-of-animal’ function:

#+begin_src emacs-lisp
  (defun type-of-animal (characteristic)  ; Second version.
    "Print message in echo area depending on CHARACTERISTIC.
  If the CHARACTERISTIC is the string \"fierce\",
  then warn of a tiger; else say it is not fierce."
    (if (equal characteristic "fierce")
        (message "It is a tiger!")
      (message "It is not fierce!")))

  (type-of-animal "fierce")"It is a tiger!"
  (type-of-animal "striped")"It is not fierce!"
#+end_src

** Truth & Falsehood
In Lisp, the predicate “false” is represented by the symbol ‘nil’.  Anything
else (anything at all) is “true”.

The expression that tests for truth is interpreted as “true” if the result of
evaluating it is a value that is not ‘nil’.  In other words, the result of the
test is considered true if the value returned is a number such as 42, a string
such as ‘"hello"’, or a symbol (other than ‘nil’) such as ‘flowers’, or a list
(so long as it is not empty), or even a buffer.  If some other useful value is
not available for the test that returns true, then the Lisp interpreter will
return the symbol ‘t’ for true (see example under the following headline).

*** nil explained
In Emacs Lisp, the symbol ‘nil’ has two meanings.  First, it means the empty
list.  Second, it means false and is the value returned when a
true-or-false-test tests false.  ‘nil’ can be written as an empty list, ‘()’, or
as ‘nil’.  As far as the Lisp interpreter is concerned, ‘()’ and ‘nil’ are the
same:

#+begin_src emacs-lisp
  (equal () nil)
#+end_src

#+RESULTS:
: t

** save-excursion
The ‘save-excursion’ function is a special form that saves the location of the
point, executes the body of the function, and then restores point to its
previous position if its location has changed.

*** Point and mark
“Point” is the current location of the cursor.  More precisely, on terminals
where the cursor appears to be on top of a character, point is the immediately
before the character.  In Emacs Lisp, point is an integer.  The function ‘point’
returns the current position of the cursor as a number.  Each buffer has its own
value for point.

The “mark” is another position in the buffer; its value can be set with a
command such as ‘set-mark-command’ (‘C-<SPC>’).  If a mark has been set, the
command ‘exchange-point-and-mark’ (‘C-x C-x’) causes the cursor to jump to the
mark and set the mark to be the previous position of point.  In addition,
setting another mark saves the position of the previous mark in the mark ring.
Many mark positions can be saved this way.  The prefixed command ‘C-u C-<SPC>’
will jump to mark, and set the mark from position popped off the local mark
ring.  Thus, successive invocations of ‘C-u C-<SPC>’ will sequentially jump to
each previous positions of the mark kept in the mark ring.

The part of the buffer between point and mark is called “the region”.  Numerous
commands work on the region, including ‘center-region’, ‘count-lines-region’,
‘kill-region’, and ‘print-region’.

The ‘save-excursion’ special form saves the location of point and restores this
position after the cod ewithin the body of the special form is evaluated by the
Lisp interpreter.

*** Template for save-excursion
The template for save-excursion is as follows:

#+begin_src emacs-lisp
  (save-excursion
    BODY...)
#+end_src

The body of the function is one or more expressions that will be evaluated in
sequence by the Lisp interpreter.  If there is more than one expression in the
body, the value of the last one will be returned as the value of the
‘save-excursion’ function.  The other expressions in the body are evaluated only
for their side effects; and ‘save-excursion’ itself is used only for its side
effect (which is restoring the position of point).

In Emacs Lisp code, a ‘save-excursion’ expression often occurs within the body
of a ‘let’ expression:

#+begin_src emacs-lisp
  (let VARLIST
    (save-excursion
      BODY...))
#+end_src

** Review
This is a review of the macros, function definitions and special forms covered
so far.

*** ‘eval-last-sexp’
Evaluate the last symbolic expression before the current location of point.  The
value is printed in the echo area unless the function is invoked with an
argument; in that case, the output is printed in the current buffer.  This
command is normally bound to ‘C-x C-e’.

*** ‘defun’
Define function.  This macro has up to five parts: the name, a template for the
arguments that will be passed to the function, documentation, an optional
interactive declaration, and the body of the definition.

For example, in Emacs the funciton definition of ‘dired-unmark-all-marks’ is as
follows.

#+begin_src emacs-lisp
  (defun dired-unmark-all-marks ()
    "Remove all marks from all files in the Dired buffer."
    (interactive)
    (dired-unmark-all-files ?\r))
#+end_src

*** ‘interactive’
Declare to the interpreter that the function can be used interactively.  This
special form may be followed by a string with one or more parts that pass the
information to the arguments of the function, in sequence.  These parts may also
tell the interpreter to prompt for information.  Parts of the string are
separated by newlines, ‘\n’.

Common code characters are:

+ ‘b’: The name of an existing buffer.
+ ‘f’: The names of an existing file.
+ ‘p’: The numeric prefix argument.  (Note that this ‘p’ is lower case.)
+ ‘r’: Point and the mark, as two numeric arguments, smallest first.  This is
  the only code letter that specifies two successive arguments rather than one.

*** ‘let’
Declare that the list of variables is for use within the body of the ‘let’ and
give them an initial value, either ‘nil’ or a specified value; then evaluate the
rest of the expressions in the body of the ‘let’ and return the value of the
last one.  Inside the body of the ‘let’, the Lisp interpreter does not see the
values of the variables of the same names that are bound outside of the ‘let’.

For example,

#+begin_src emacs-lisp
  (let ((foo (buffer-name))
        (bar (buffer-size)))
    (message
     "This buffer is %s and has %d characters."
     foo bar))
#+end_src

*** ‘save-excursion’
Record the values of point and the current buffer before evaluating the body of
this special form.  Restore the value of point and buffer afterwards.

For example,

#+begin_src emacs-lisp
  (message "We are %d characters into this buffer."
           (- (point)
              (save-excursion
                (goto-char (point-min))
                (point))))
#+end_src

#+RESULTS:
: We are 39114 characters into this buffer.

*** ‘if’
Evaluate the first argument to the function; if it is true, evaluate the seconds
argument; else evaluate the third argument, if there is one.

The ‘if’ special form is called “conditional”.  There are other conditionals in
Emacs Lisp, but ‘if’ is perhaps the most commonly used.

For example,

#+begin_src emacs-lisp
  (if (= 22 emacs-major-version)
      (message "This is version 22 of Emacs.")
    (message "This is not version 22 of Emacs."))
#+end_src

*** ‘<’, ‘>’, ‘<=’ & ‘>=’
The ‘<’ function tests whether its first argument is smaller than its second
argument.  A corresponding function, ‘>’, tests whether the first argument is
greater than the second.  Likewise, ‘<=’ tests whether the first argument is
less than or equal to the second and ‘>=’ tests whether the first argument is
greater than or equal to the second.  In all cases, both arguments must be
numbers or markers (markers indicate positions in buffers).

*** ‘=’
The ‘=’ function tests whether two arguments, both numbers or markers, are
equal.

*** ‘equal’ & ‘eq’
Tests whether two objects are the same.  ‘equal’ uses one meaning of the word
“same” and ‘eq’ uses another: ‘equal’ returns true if the two objects have a
similar structure and contents, such as two copies of the same book.  On the
other hand, ‘eq’ returns true if both arguments are actually the same object.

*** ‘string<’, ‘string-lessp’, ‘string=’ & ‘string-equal’
The ‘string-lessp’ function tests whether its first argument is smaller than the
second argument.  A shorter, alternative name for the same function (a
‘defalias’) is ‘string<’.

The arguments to ‘string-lessp’ must be strings or symbols; the ordering is
lexicographic, so case is significant.  The print names of symbols are used
insteada of the symbols themselves.

An empty string, ‘""’, a string with no characters in it, is smaller than any
string of characters.

‘string-equal’ provides the corresponding test for equality.  Its shorter
alternative name is ‘string=’.  There are no string test functions that
correspond to ‘>’, ‘>=’, or ‘<=’.

*** ‘message’
Print a message in the echo area.  The first argument is a string that can
contain ‘%s’, ‘%d’, or ‘%c’ to print the value of arguments that follow the
string.  The argument used by ‘%s’ must be a string or a symbol; the argument
used by ‘%d’ must be a number.  The argument used by ‘%c’ must be an ASCII code
number; it will be printed as the character with that ASCII code.  (Various
other %-sequences also exist.)

*** ‘setq’ & ‘set’
The ‘setq’ function sets the value of its first argument to the value of the
second argument.  The first argument is automatically quoted by ‘setq’.  It does
the same for suceeding pairs of arguments.  Another function, ‘set’, takes only
two arguments and evaluates both of them before setting the value returned by
its first argument to the value returned by its second argument.

*** ‘buffer-name’
Without an argument, return the name of the buffer, as a string.

*** ‘buffer-file-name’
Without an argument, return the name of the file the buffer is visiting.

*** ‘current-buffer’
Return the buffer in which Emacs is active; it may not be the buffer that is
visible on screen.

*** ‘other-buffer’
Return the most recently selected buffer (other than the buffer passed to
‘other-buffer’ as an argument and other than the current buffer).

*** ‘switch-to-buffer’
Select a buffer for Emacs to be active in and display it in the current window
so users can look at it.  Usually bound to ‘C-x b’.

*** ‘set-buffer’
Switch Emacs’s attention to a buffer on which programs will run.  Don’t alter
what the window is showing.

*** ‘buffer-size’
Return the number of characters in the current buffer.

*** ‘point’
Return the value of the current position of the cursor, as an integer counting
the number of characters from the beginning of the buffer.

*** ‘point-min’
Return the minimum permissible value of point in the current buffer.  This is
one, unless narrowing is in effect.

*** ‘point-max’
Return the value of the maximum permissible value of point in the current
buffer.  This is the end of the buffer, unless narrowing is in effect.

** Exercises
*** Exercise 3.1
Write a non-interactive function that doubles the value of its argument, a
number.  Make that function interactive.

#+begin_src emacs-lisp
  (defun double-me (number)             ; non-interactive version
    "Returns twice the value of NUMBER."
    (* 2 number))

  (double-me 3) ; 6

  (defun double-me (number)             ; interactive-version
    "Returns twice the value of NUMBER."
    (interactive "p")
    (message "%d is twice the value of %d"
             (* 2 number)
             number))
#+end_src

*** Exercise 3.2
Write a function that tests whether the current value of ‘fill-column’ is
greater than the argument passed to the function, and if so, prints an
appropriate message.

#+begin_src emacs-lisp
  (defun fill-column-compare (number)
    "Compares value of NUMBER with the value of `fill-column'."
    (interactive "p")
    (if (> fill-column number)
        (message "The number %d is lesser than the value of `fill-column' (%d)"
                 number fill-column)
      (message "The number %d is equal or bigger than the value of `fill-column' (%d)"
               number fill-column)))
#+end_src

* Buffer Walk Through
This chapter covers some GNU Emacs buffer-related functions.

** Finding More
Emacs Lisp function are documented.  Their documentation can be reached via the
command ‘describe-function’ (bound to ‘C-h f’).  Similarly, the full
documentation of a variable can be perused via the command ‘describe-variable’
(bound to ‘C-h v’).

To enquire a function’s original source file, refer to the function
‘xref-find-definitions’.  ‘xref-find-definitions’ works with a variety of
languages, not just Lisp and C, and it works with non-programming text as well.
For example, ‘xref-find-definitions’ will jump to the various nodes in the
Texinfo source file of an Info document (provided that the ‘etags’ utility was
run to record all the nodes in the manuals that comes with Emacs).

** A Simplified ‘beginning-of-buffer’ Definition
As an interactive command, ‘beginning-of-buffer’ moves the cursor to the
beginning of the buffer, leaving the mark at the previous position.  It is
generally bound to ‘M-<’.

Here is a simplified version of the actual function definition:

#+begin_src emacs-lisp
  (defun simplified-beginning-of-buffer ()
    "Move point to the beginning of the buffer;
  leave mark at previous position."
    (interactive)
    (push-mark)
    (goto-char (point-min)))
#+end_src

** The Definition of ‘mark-whole-buffer’
The ‘mark-whole-buffer’ funciton marks a while buffer as a region by putting
point at the beginning and a mark at the end of the buffer.  It is generally
bound to ‘C-x h’.

*** ‘mark-whole-buffer’ overview
In GNU Emacs 22, the code for the complete function looks like this:

#+begin_src emacs-lisp
  (defun mark-whole-buffer ()
    "Put point at beginning and mark at end of buffer.
  You probably should not use this function in Lisp programs;
  it is usually a mistake for a Lisp function to use any subroutine
  that uses or sets the mark."
    (interactive)
    (push-mark (point))
    (push-mark (point-max) nil t)
    (goto-char (point-min)))
#+end_src

*** Body of ‘mark-whole-buffer’
In the line,

#+begin_src emacs-lisp
  (push-mark (point-max) nil t)
#+end_src

the first argument, ‘(point-max)’, tells the function to set the mark at the
point in the buffer that has the highest number.  The second argument, ‘nil’,
instructs the function to display a message that says “Mark set” when it pushes
the mark.  The third argument, ‘t’, tells ‘push-mark’ to activate the mark when
Transient Mark mode is turned on.  Transient Mark mode highlights the current
active region (it often turned off).

** The Definition of ‘append-to-buffer’
The ‘append-to-buffer’ command copies the region (that is, the part of the
buffer between point and mark) from the current buffer to a specified buffer.

*** An Overview of ‘append-to-buffer’
The ‘append-to-buffer’ command uses the ‘insert-buffer-substring’ function to
copy the region.  ‘insert-buffer-substring’ takes a substring from a buffer, and
inserts it into another buffer.

Here is the text of the ‘append-to-buffer’ function (at the date of the writing
of the book; it has since been amended):

#+begin_src emacs-lisp
  (defun append-to-buffer (buffer start end)
    "Append to specified buffer the text of the region.
  It is inserted into that buffer before its point.

  When calling from a program, give three arguments:
  BUFFER (or buffer name), START and END.
  START and END specify the portion of the current buffer to be copied."
    (interactive
     (list (read-buffer "Append to buffer: " (other-buffer
                                              (current-buffer) t))
           (region-beginning) (region-end)))
    (let ((oldbuf (current-buffer)))
      (save-excursion
        (let* ((append-to (get-buffer-create buffer))
               (windows (get-buffer-window-list append-to t t))
               point)
          (set-buffer append-to)
          (setq point (point))
          (barf-if-buffer-read-only)
          (insert-buffer-substring oldbuf start end)
          (dolist (window windows)
            (when (= (window-point window) point)
              (set-window-point window (point))))))))
#+end_src

The function has three arguments: the ‘buffer’ to which the text will be copied,
and the ‘start’ and the ‘end’ of the region in the current buffer that will be
copied.  As stated in the documentation, the function can handle both the
destination buffer and its name.

*** The ‘append-to-buffer’ Interactive Expression
The interactive expression contains a list composed of three parts.  The first
part of this list is an expression to read the name of a buffer and return it as
a string.  This is achieved through the function ‘read-buffer’.  This functions
requires a prompt as its first argument, ‘"Append to buffer: "’.  Its second
argument tells the command what value to provide if nothing is specified.

This fallback argument is an expression calling the function ‘other-buffer’, an
exception, and the symbol ‘t’, standing for true.  This means that, should the
user not provide a buffer to append the region to, the function will take the
most recent buffer other than the current buffer (regardless of whether it is
visible or not) as its BUFFER argument.

*** The Body of ‘append-to-buffer’
The body of the function is wrapped in a ‘let’ statement.  This statement binds
the value returned by ‘(current-buffer)’ to the variable ‘oldbuf’.  This
variable will be used to keep track of the current working buffer.

*** ‘save-excursion’ in ‘append-to-buffer’
The body of the ‘let’ expression in ‘append-to-buffer’ consists of a
‘save-excursion’ expression.

The body of the ‘save-excursion’ expression is itself wrapped in a ‘let*’
expression.  This command behaves in the same manner as the ‘let’ special form,
except that it allows for variables set later in its VARLIST to make use of the
values to which Emacs set variables earlier in the VARLIST.

The ‘set-buffer’ function makes its argument (expressed as a buffer or a buffer
name) current for editing operations.  The variable ‘append-to’ is fed as an
argument to the ‘set-buffer’ call; this variable is bound to
‘(get-buffer-create buffer)’ earlier in the ‘let*’ expression.

The function that does the actual job is ‘insert-buffer-substring’.  Because
this function copies text /from/ a specified third party buffer to the current
buffer (the reverse operation we want to perform), ‘append-to-buffer’ first
switches focus to the destination buffer, making it the current one.  Then it
makes a call to ‘insert-buffer-substring’, taking text from ‘oldbuf’ (the one
from which the call to ‘append-to-buffer’ is issued) to the buffer designated as
‘append-to’.

Once the string is appended, focus is returned to the starting buffer through
the closing of the ‘save-excursion’ expression.

Written in skeletal form, the workings of the ‘append-to-buffer’ function look
like this:

#+begin_src emacs-lisp
  (let (BIND-oldbuf-TO-VALUE-OF-current-buffer)
    (save-excursion                       ; Keep track of buffer.
      CHANGE-BUFFER
      INSERT-SUBSTRING-FROM-oldbuf-INTO-BUFFER)

    CHANGE-BACK-TO-ORIGINAL-BUFFER-WHEN-FINISHED
    LET-THE-LOCAL-MEANING-OF-oldbuf-DISAPPEAR-WHEN-FINISHED)
#+end_src

** Review
Here is a summary of the functions covered in this chapter.

*** ‘describe-function’ & ‘describe-variable’
Print the documentation for a function or variable.  Conventionally bound to
‘C-h f’ and ‘C-h v’.

*** ‘xref-find-definitions’
Find the file containing the source for a function or variable and switch
buffers to it, positioning point at the beginning of the item.  Conventionally
bound to ‘M-.’.

*** ‘save-excusrion’
Save the location of point and restore its value after the arguments to
‘save-excusrion’ have been evaluated.  Also, remember the current buffer and
return to it.

*** ‘push-mark’
Set mark at a location and record the value of the previous mark on the mark
ring.  The mark is a location in the buffer that will retain its relative
position even if text is added to or removed from the buffer.

*** ‘goto-char’
Set point to the location specified by the value of the argument, which can be a
numberm a marker, or an expression that returns the number of a position, such
as ‘(point-min)’.

*** ‘insert-buffer-substring’
Copy a region of text from a buffer that is passed to the function as an
argument and insert the region into the current buffer.

*** ‘mark-whole-buffer’
Mark the whole buffer as a region.  Normally bound to ‘C-x h’.

*** ‘set-buffer’
Switch the focus of Emacs to another buffer, but do not change the window being
displayed.  Used when the program rather than a human it to work on a different buffer.

*** ‘get-buffer-create’ & ‘get-buffer’
Find a named buffer or create one if a buffer of that name does not exist.  The
‘get-buffer’ function returns ‘nil’ if the named buffer does not exist.

** Exercises
*** Exercise 4.1
Write a ‘simplified-end-of-buffer’ function; then test to see whether it works.

#+begin_src emacs-lisp
  (defun simplified-end-of-buffer ()
      "Go the the end of the buffer."
    (interactive)
    (goto-char (point-max)))
#+end_src

*** Exercise 4.2
Use ‘if’ and ‘get-buffer’ to write a function the prints a message telling
whether a buffer exists.

#+begin_src emacs-lisp
  (defun is-bufferp (buffer)
    "Determines whether buffer BUFFER exists."
    (interactive "BBuffer:")
    (if (get-buffer buffer)
        (message "Buffer %s does exist!" buffer)
      (message "Buffer %s does not exist." buffer)))
#+end_src

*** Exercise 4.3
Using ‘xref-find-definitions’, find the source for the ‘copy-to-buffer’
function.

#+begin_src emacs-lisp
  (xref-find-definitions 'copy-to-buffer)
#+end_src

* More Complex
More complex examples follow: ‘copy-to-buffer’ and ‘insert-buffer’.

** ‘copy-to-buffer’
This function behaves just like ‘append-to-buffer’, except that it replaces the
text in the target buffer instead of adding to it.  The body of ‘copy-to-buffer’
(at the time of the writing of the book) is as follows:

#+begin_src emacs-lisp
  ...
     (interactive "BCopy to buffer: \nr")
     (let ((oldbuf (current-buffer)))
       (with-current-buffer (get-buffer-create buffer)
         (barf-if-buffer-read-only)
         (erase-buffer)
         (save-excursion
           (insert-buffer-substring oldbuf start end))))
#+end_src

The function ‘with-current-buffer’ will execute its body with the buffer given
as its first argument (the buffer to copy to) in focus.  Its body is composed of
a ‘saved-excursion’ special form wherein the contents of the target buffer are
first erased, then replaced by the region to copy from the current buffer (via
an ‘insert-buffer-substring’ call).

An outline of the body of ‘copy-to-buffer’ looks like this:

#+begin_src emacs-lisp
  (let (BIND-oldbuf-TO-VALUE-OF-current-buffer)
    (WITH-THE-BUFFER-YOU-ARE-COPYING-TO
     (BUT-DO-NOT-ERASE-OR-COPY-TO-A-READ-ONLY-BUFFER)
     (erase-buffer)
     (save-excursion
       INSERT-SUBSTRING-FROM-oldbuf-INTO-BUFFER)))
#+end_src

** The Definition of ‘insert-buffer’
The function ‘insert-buffer’ copies another buffer /into/ the current buffer.
It is the reverse of ‘append-to-buffer’ or ‘copy-to-buffer’, since they copy a
region of text /from/ the current buffer to another buffer.

*** The Code for ‘insert-buffer’
Here is the code of the definition (this is not the code of the current
implementation in Emacs):

#+begin_src emacs-lisp
  (defun insert-buffer (buffer)
    "Insert after point the contents of BUFFER.
       Puts mark after the inserted text.
       BUFFER may be a buffer or a buffer name."
    (interactive "*bInsert buffer: ")
    (or (bufferp buffer)
        (setq buffer (get-buffer buffer)))
    (let (start end newmark)
      (save-excursion
        (save-excursion
          (set-buffer buffer)
          (setq start (point-min) end (point-max)))
        (insert-buffer-substring buffer start end)
        (setq newmark (point)))
      (push-mark newmark)))
#+end_src

*** The Interactive Expression in ‘insert-buffer’
In ‘insert-buffer’, the argument to the ‘interactive’ declaration has two parts,
an asterisk, ‘*’, and ‘bInsert buffer: ’.

**** A Read-only buffer
The asterisk is for the situation when the current buffer is a read-only buffer
(a buffer that cannot be edited).  If ‘insert-buffer’ is called when the current
buffer is read-only, a message to this effect is printed in the echo area and
the terminal may beep of blink; as a consequence, no text will be inserted into
current buffer.  The asterisk does not need to be followed by a newline to
separate it from the next argument.

**** ‘b’ in an Interactive Expression
The next argument in the interactive expression starts with a lower case ‘b’.
The lower-case ‘b’ tells the Lisp interpreter that the argument for
‘insert-buffer’ should be an existing buffer (or else its name).  (The
upper-case ‘B’ option provides for the possibility that the buffer does not
exist.)  Emacs will prompt for the name of the buffer, offering a default
buffer, with name completion enabled.  If the buffer does not exist, the message
“No match” is returned; the terminal may beep as well.

*** The Body of the ‘insert-buffer’ Function
The body of the ‘insert-buffer’ function has two major parts: an ‘or’ expression
and a ‘let’ expression.  The purpose of the ‘or’ expression is to ensure that
the argument ‘buffer’ is bound to a buffer and not just the name of a buffer.
(The ‘or’ function evaluates its arguments until one of them yields non-nil,
then returns that value.)

The body of the ‘let’ expression contains the code which copies the other buffer
into the current buffer.

*** ‘insert-buffer’ with an ‘if’ instead of an ‘or’
The goal of the ‘or’ expression is to ensure that the value of ‘buffer’ is a
buffer and not the name of a buffer.  Should the value be a name, then buffer
itself must be return.

Using a predicate called ‘bufferp’ that tells us whether we have a buffer
(rather than its name), we can formulate the ‘if’ statement code like this:

#+begin_src emacs-lisp
  (if (not (bufferp buffer))            ; if-part
      (setq buffer (get-buffer buffer))) ; then-part
#+end_src

*** The ‘or’ in the Body
An ‘or’ expression can have any number of arguments.  It evaluates each argument
in turn and returns the value ot the first of its arguments that is not ‘nil’.
In addition, it refrains to evaluate any subsequent arguments after returning
the first non-‘nil’ value.

*** The ‘let’ Expression in ‘insert-buffer’
The whole ‘let’ expression looks like this:

#+begin_src emacs-lisp
  (let (start end mark)
    (save-excursion
      (save-excursion
        (set-buffer buffer)
        (setq start (point-min)
              end (point-max)))
      (insert-buffer-substring buffer start end)
      (setq newmark (point)))
    (push-mark newmark))
#+end_src

There are two nested ‘save-excursion’ forms within the ‘let’ expression.  The
innermost one moves focus to the buffer to copy and binds the variables ‘start’
and ‘end’ to the values of ‘point-min’ and ‘point-max’ in that buffer.  Once
these variables are set, focus returns to the current buffer and the contents of
the buffer to copy are inserted via the function ‘insert-buffer-substring’.

Then, a new position of the mark, located at the end of the copied text, is
pushed to the mark ring.

Once the execution of the instructions within the outer ‘save-excursion’ call
are completed, point is restored to the beginning of the inserted text (which is
where it was before the insert function was called).

*** New  Body for ‘insert-buffer’
In more recent Emacs’ iterations, the body of the ‘insert-buffer’ function
consists of two expressions, as follows:

#+begin_src emacs-lisp
  (push-mark
   (save-excursion
     (insert-buffer-substring (get-buffer buffer))
     (point)))
#+end_src

Here, the ‘get-buffer’ call returns a buffer with the provided name.  This
buffer is passed to the ‘insert-buffer-substring’ command, which then proceeds
to insert the whole of the buffer in the current location at point.  The
location of point at the end of the inserted text is finally pushed to the
mark ring.  Notice that the function returns ‘nil’, i.e., the intended result of
the ‘insert-buffer’ function is obtained as a side effect.

** Complete Definition of ‘beginning-of-buffer’
Here we consider the actual full definition of the ‘beginning-of-buffer’
function.  The implemented version of ‘beginning-of-buffer’ has functionality to
take an integer argument between one and ten and then move point to that
fraction of the way, measured in tenths, from the beginning of the buffer.

*** Optional Arguments
Unless stated otherwise, Lisp expects that a function with an argument in its
function definition will be called with a value for that argument.  If that does
not happen, the interpreter throws an error message that says, ‘Wrong number of
arguments’.

However, optional arguments are a feature of Lisp: a particular “keyword” is
used to tell the interpreter that an argument is optional.  That keyword is
‘&optional’.  In a function definition, if an argument follows the keyword
‘&optional’, no value needs to be passed to that argument when the function is
called.

This is relevant to the function ‘beginning-of-buffer’, whose outline looks like
this:

#+begin_src emacs-lisp
  (defun beginning-of-buffer (&optional arg)
    "DOCUMENTATION..."
    (interactive "P")
    (or (IS-THE-ARGUMENT-A-CONS-CELL arg)
        (and ARE-BOTH-TRANSIENT-MARK-MODE-AND-MARK-ACTIVE-TRUE)
        (push-mark))
    (let (DETERMINE-SIZE-AND-SET-IT)
      (goto-char
       (IF-THERE-IS-AN-ARGUMENT
        FIGURE-OUT-WHERE-TO-GO
        ELSE-GO-TO
        (point-min))))
    DO-NICETY)
#+end_src

The function resembles the ‘simplified-beginning-of-buffer’ function except that
the ‘interactive’ expression has a ‘"P"’ as an argument and the ‘goto-char’
call is followed by an if-then-else statement that figures out where to put the
cursor if there is an argument that is not a cons cell (more on cons cells
later).

The ‘"P"’ in the ‘interactive’ expression tells Emacs to pass a prefix argument,
if there is one, to the function in raw form.  A lowercase ‘"p"’ would cause the
function to convert the prefix argument to a number.

The true-or-false-test of the ‘if’ expression checks whether ‘arg’ has a
non-‘nil’ value; if it does, the then-part of the ‘if’ expression is evaluated.
Alternatively, should the function not be called with an argument, the value of
‘arg’ defaults to ‘nil’ and the else-part of the ‘if’ expression is evaluated.
The else-part is simply ‘point-min’, and when this is the outcome, the whole
‘goto-char’ expression is ‘(goto-char (point-min))’, which is exactly how we
formulated the ‘beginning-of-buffer’ function in its simplified form.

*** ‘beginning-of-buffer’ with an Argument
When ‘beginning-of-buffer’ of buffer is called with an argument, an expression
is evaluated which calculates what value to pass to ‘goto-char’.  This
expression looks as follows:

#+begin_src emacs-lisp
  (if (> (buffer-size) 10000)
      ;; Avoid overflow for large buffer sizes!
      (* (prefix-numeric-value arg)
         (/ size 10))
    (/
     (+ 10
        (*
         size (prefix-numeric-value arg))) 10))
#+end_src

**** Disentangle ‘beginning-of-buffer’
In skeletal form, the expression looks like this:

#+begin_src emacs-lisp
  (if (BUFFER-IS-LARGE)
      DIVIDE-BUFFER-SIZE-BY-10-AND-MULTIPLY-BY-ARG
    ELSE-USE-ALTERNATE-CALCULATION)
#+end_src

**** What Happens in a Large Buffer
In ‘beginning-of-buffer’, the inner ‘if’ expression tests whether the size of
the buffer exceeds 10,000 characters.  To do this, it uses the ‘>’ function and
the computation of size that comes with the ‘let’ expression.  Then, this
multiplication is performed:

#+begin_src emacs-lisp
  (*
   (prefix-numeric-value arg)
   (/ size 10))
#+end_src

The function ‘prefix-numeric-value’ returns the “numeric meaning of the raw
prefix argument arg”.  This is because the value of ‘arg’ was captured by the
‘interactive’ flag ‘"P"’, as a “raw prefix argument”.

As a result, if the accessible portion of the buffer is deemed as large, the
‘goto-char’ expression reads like this:

#+begin_src emacs-lisp
  (goto-char (* (prefix-numeric-value arg)
                (/ size 10)))
#+end_src

**** What Happens in a Small Buffer
If the buffer contains fewer than 10,000 characaters, a slightly different
computation is performed.  It looks like this:

#+begin_src emacs-lisp
  (/
   (+
    10
    (*
     size
     (prefix-numeric-value arg)))
   10)
#+end_src

The integer issued from this computation is passed to ‘goto-char’ and the cursor
is moved to that position.

*** The Complete ‘beginning-of-buffer’
Here is the complete text of the ‘beginning-of-buffer’ function definition:

#+begin_src emacs-lisp
  (defun beginning-of-buffer (&optional arg)
    "Move point to the beginning of the buffer;
       leave mark at previous position.
       With \\[universal-argument] prefix,
       do not set mark at previous position.
       With numeric arg N,
       put point N/10 of the way from the beginning.

       If the buffer is narrowed,
       this command uses the beginning and size
       of the accessible part of the buffer.

       Don't use this command in Lisp programs!
       \(goto-char (point-min)) is faster
       and avoids clobbering the mark."
    (interactive "P")
    (or (consp arg)
        (and transient-mark-mode mark-active)
        (push-mark))
    (let ((size (- (point-max) (point-min))))
      (goto-char (if (and arg (not (consp arg)))
                     (+ (point-min)
                        (if (> size 10000)
                            ;; Avoid overflow for large buffer sizes!
                            (* (prefix-numeric-value arg)
                               (/ size 10))
                          (/ (+ 10 (* size (prefix-numeric-value arg)))
                             10)))
                   (point-min))))
    (if (and arg (not (consp arg))) (forward-line 1)))
#+end_src

** Review
Here is a summary of the topics covered in this chapter.

*** ‘or’
Evaluate each argument in sequence and return the value of the first argument
that is not ‘nil’; if none return a value that is not ‘nil’, return ‘nil’.

*** ‘and’
Evaluate each argument in sequence, and if any are ‘nil’, return ‘nil’; if none
are ‘nil’, return the value of the last argument.

*** ‘&optional’
A keyword used to indicate that an argument to a function definition is
optional; this means that the function can be evaluated without the argument if
desired.

*** ‘prefix-numeric-value’
Convert the raw prefix argument produced by ‘(interactive "P")’ to a numeric value.

*** ‘forward-line’
Move point forward to the beginning of the next line, or if the argument is
greater than one, forward that many lines.  If it can’t move as far forward as
it is supposed to, ‘forward-line’ goes forward as far as it can and then returns
a count of the number of additional lines it was supposed to move but couldn’t.

*** ‘erase-buffer’
Delete the entore contents of the current buffer.

*** ‘bufferp’
Return ‘t’ if its argument is a buffer; oterwise return ‘nil’.

** Exercise
Write an interactive function with an optional argument that tests whether its
argument, a number, is greater than or equal to, or else, less than the value of
‘fill-column’, and tells you which, in a message.  However, if you do not pass
an argument to the function, use 56 as a default value.

#+begin_src emacs-lisp
  (defun fill-column-compare (&optional number)
    "Compares value of NUMBER with the value of `fill-column'."
    (interactive "P")
    (setq number
          (if number
              (prefix-numeric-value number)
            56))
    (if (> fill-column number)
        (message "The number %d is lesser than the value of `fill-column' (%d)"
                 number fill-column)
      (message "The number %d is greater than or equal to the value of `fill-column' (%d)"
               number fill-column)))
#+end_src

* Narrowing & Widening
Narrowing is a feature of Emacs that makes it possible to focus on a specific
part of a buffer, and edit it without accidentally changing other parts.

** Narrowing Advantages
Potentially destructive editing operations like search & replace or the use of
macros only affect the narrowed part of the buffer.

The concept of narrowing is also useful from the perspective of the Lisp
interpreter.  For instance, the ‘what-line’ function disables narrowing while it
executes, but then restores the narrowing to what it was when it exits.  On the
other hand, the ‘count-lines’ function uses narrowing to restrict itself to just
the portion of the buffer in which it is interested and then restores the
previous situation.

** The ‘save-restriction’ Special Form
The ‘save-restriction’ special form is used to keep track of whatever narrowing
is in effect, if any.  When the Lisp interpreter meets with ‘save-restriction’,
it executes the code in the body of the ‘save-restriction’ expression, and then
undoes any changes to narrowing that the code caused.

Note that, when both ‘save-excursion’ and ‘save-restriction’ are used, one right
after the other, the ‘save-excursion’ should be used outermost.  If they are
written in reverse order, Emacs may fail to record narrowing in the buffer to
which it switches after calling ‘save-excursion’.  Thus, when invoked together,
‘save-excursion’ and ‘save-restriction’ should be written like this:

#+begin_src emacs-lisp
  (save-excursion
    (save-restriction
      BODY...))
#+end_src

** ‘what-line’
The ‘what-line’ command returns the number of the line in which the cursor is
located.  The function illustrates the use of the ‘save-restriction’ and
‘save-excursion’ instructions.  Here is the original text of the function:

#+begin_src emacs-lisp
  (defun what-line ()
    "Print the current line number (in the buffer) of point."
    (interactive)
    (save-restriction
      (widen)
      (save-excursion
        (beginning-of-line)
        (message "Line %d"
                 (1+ (count-lines 1 (point)))))))
#+end_src

** Exercise
Write a function that will display the first sixty characaters of the current
buffer, even if you have narrowed the buffer to its latter half so that the
first line is inaccessible.  Restore point, mark, and narrowing.  For this
exercise, you need to use a whole potpourri of functions, including
‘save-restriction’, ‘widen’, ‘goto-char’, ‘point-min’, ‘message’, and
‘buffer-substring’.

#+begin_src emacs-lisp
(defun gtms-top-sixty ()
  "Return the first sixty characters of the current buffer,
  regardless of the narrowing status of the buffer."
  (interactive)
  (save-excursion
    (save-restriction
      (widen)
      (message "These are the first 60 characters in this buffer:\n%s"
               (buffer-substring-no-properties 1 60)))))
#+end_src

* ‘car’, ‘cdr’ & ‘cons’: Fundamental Functions
In Lisp, ‘car’, ‘cdr’, and ‘cons’ are fundamental functions.  The ‘cons’
function is used to construct lists, and the ‘car’ and ‘cdr’ functions are used
to take them apart.

** Strange Names
The name of the ‘cons’ function is an abbreviation of the word “construct”.  On
the other hand, the origins of the names for the ‘car’ and ‘cdr’ functions are
less straightforward: ‘car’ is an acronym from the phrase “Contents of the
Address part of the Register”; and ‘cdr’ (pronounced “could-er”) is an acronym
from the phrase “Contents of the Decrement part of the Register”.  These phrases
refer to specific pieces of hardware on the very early computer on which the
original Lisp was developed.

** ‘car’ and ‘cdr’
The CAR of a list is the first element of that list.  Thus the CAR of the list
‘'(rose violet daisy buttercup)’ is ‘rose’:

#+begin_src emacs-lisp
  (car '(rose violet daisy buttercup)) ; rose
#+end_src

#+RESULTS:
: rose

The CDR of a list is the /rest/ of the list (i.e., anything /beyond/ its first
element).  Thus, while the CAR of the list ‘'(rose violet daisy buttercup)’ is
‘rose’, the rest of the list, the value returned by the ‘cdr’ function, is
‘'(violet daisy buttercup)’:

#+begin_src emacs-lisp
  (cdr '(rose violet daisy buttercup)) ;; (violet daisy buttercup)
#+end_src

#+RESULTS:
| violet | daisy | buttercup |

Both ‘car’ and ‘cdr’ are “non-destructive”: they do not change the object to
which they apply.

When undertaking a list of lists, car will return the first element of its
argument, itslef a list:

#+begin_src emacs-lisp
  (car '((lion tiger cheetah)
         (gazelle antelope zebra)
         (whale dolphin seal))) ;; (lion tiger cheetah)
#+end_src

#+RESULTS:
| lion | tiger | cheetah |

In the example above, the rest of the list would be a list of lists as
well:

#+begin_src emacs-lisp
  (cdr '((lion tiger cheetah)
         (gazelle antelope zebra)
         (whale dolphin seal)))  ;; ((gazelle antelope zebra) (whale dolphin seal))
#+end_src

#+RESULTS:
| gazelle | antelope | zebra |
| whale   | dolphin  | seal  |

** ‘cons’
The ‘cons’ function constructs lists; it performs the reverse operation of ‘car’
and ‘cdr’.  For example, ‘cons’ can be used to make a four element list from the
three element list, ‘'(fir oak, maple)’:

#+begin_src emacs-lisp
  (cons 'pine '(fir oak maple)) ;; (pine fir oak maple)
#+end_src

#+RESULTS:
| pine | fir | oak | maple |

Just like ‘car’ and ‘cdr’, ‘cons’ is non-destructive: the original list is /not/
modified; rather, a /new/ one is constructed.

*** Build a List
‘cons’ must have a list to attach to.  If a list is being built from nothing, an
empty list has to be provided to ‘cons’.  Here is a series of ‘cons’ expressions
that build up a list of flowers:

#+begin_src emacs-lisp
  (cons 'buttercup nil) ;; (buttercup)
  (cons 'daisy '(buttercup)) ;; (daisy buttercup)
  (cons 'violet '(daisy buttercup)) ;; (violet daisy buttercup)
  (cons 'rose '(violet daisy buttercup)) ;; (rose violet daisy buttercup)
#+end_src

*** Find the Length of a List: ‘length’
The number of elements of a list can be found by using the Lisp function
‘length’:

#+begin_src emacs-lisp
  (length '(buttercup)) ; 1
  (length '(daisy buttercup)) ; 2
  (length (cons 'violet '(daisy buttercup))) ; 3
#+end_src

‘length’ will also return the number of elements in the empty list:

#+begin_src emacs-lisp
  (length ()) ; 0
#+end_src

#+RESULTS:
: 0

** ‘nthcdr’
The ‘nthcdr’ function is associated with the ‘cdr’ function.  It returns the
result of applying cdr N times to a list:

#+begin_quote
(nthcdr N LIST)

Take cdr N times on LIST, return the result.
#+end_quote

Thus, the two following examples return the same list:

#+begin_src emacs-lisp
  (cdr (cdr '(pine fir oak maple))) ;; (oak maple)
  (nthcdr 2 '(pine fir oak maple)) ;; (oak maple)
#+end_src

Using the original four element list, here is what happens when various numeric
arguments are passed to ‘nthcdr’, including zero, one and five:

#+begin_src emacs-lisp
  ;; Leave the list as it was.
  (nthcdr 0 '(pine fir oak maple)) ;; (pine fir oak maple)

  ;; Return a copy without the first element.
  (nthcdr 1 '(pine fir oak maple)) ;; (fir oak maple)

  ;; Return a copy without the first three elements.
  (nthcdr 3 '(pine fir oak maple)) ;; (maple)

  ;; Return a copy devoid of ALL elements.
  (nthcdr 5 '(pine fir oak maple)) ; nil
#+end_src

** ‘nth’
The ‘nthcdr’ takes the CDR of a list repeatedly.  The ‘nth’ function takes the
CAR of the result returned by ‘nthcdr’: it returns the Nth element of the list.

#+begin_quote
(nthcdr N LIST)

Take cdr N times on LIST, return the result.
#+end_quote

Thus, if it were not defined in C for speed, the definition of ‘nth’ would be:

#+begin_src emacs-lisp
  (defun nth (n list)
    "Returns the Nth element of LIST.
  N counts from zero.  If LIST is not that long, nil is retured."
    (car (nthcdr n list)))
#+end_src

The ‘nth’ function returns a single element of a list.

Note that the elements are numbered from zero, not one.  That is to say, the CAR
of the first element of a list is the /zeroth/ element:

#+begin_src emacs-lisp
  (nth 0 '("one" "two" "three")) ; "one"
  (nth 1 '("one" "two" "three")) ; "two"
#+end_src

Just like ‘nthcdr’ and ‘cdr’, ‘nth’ is non-destructive; it does /not/ change the
original list.  (This is in contrast with the ‘setcar’ and ‘setcdr’ functions.)

** ‘setcar’
The ‘setcar’ and ‘setcdr’ functions /set/ the CAR and the CDR of a list to new
values.  Unlike ‘car’ and ‘cdr’, they do change the original list.  To see how
this works, consider the following exercise:

#+begin_src emacs-lisp
  ;; Define variable `animals'
  (setq animals '(antelope giraffe lion tiger)) ;; (antelope giraffe lion tiger)

  ;; Set (destructively) the first element of the list pointed to by `animals' to `hippopotamus'
  (setcar animals 'hippopotamus)

  ;; The symbol `animals' now points to a different list
  animals ;; (hippopotamus giraffe lion tiger)
#+end_src

Initially, the variable ‘animals’ was set to point to the list ‘'(antelope
giraffe lion tiger)’.  The ‘setcar’ command destructively set its first element
to ‘hippopotamus’ (it was previously ‘antelope’).  In effect, the list pointed
to by the symbol ‘animals’ was changed in memory.  Its first element was
replaced from ‘antelope’ to ‘hippopotamus’.

** ‘setcdr’
The ‘setcdr’ function is similar to the ‘setcar’ function, except that the
function replaces the /second and subsequent/ elements of a list rather than its
first element.  It is exemplified in the following snippet:

#+begin_src emacs-lisp
  ;; Define variable `domesticated-animals'
  (setq domesticated-animals '(horse cow sheep goat)) ;; (horse cow sheep goat)

  ;; Set (destructively) the second to last elements of the list point to by
  ;; `domesticated-animals' to the list '(cat dog)
  (setcdr domesticated-animals '(cat dog))

  ;; The symbol `domesticated-animals' now points to a different list
  domesticated-animals ;; (horse cat dog)
#+end_src

Initially, the variable ‘domesticated-animals’ was set to point to the list
‘'(horse cow sheep goat)’.  The ‘setcdr’ command destructively set its second to
last elements to the list ‘'(cat dog)’ (it was previously ‘'(cow sheep goat)’).
In effect, the list pointed to by the symbol ‘domesticated-animals’ was changed
in memory.  Its second to last element were replaced from ‘'(cow sheep goat)’ to
‘'(cat dog)’.

** Exercise
Construct a list of four birds by evaluating several expressions with ‘cons’.
Find out what happens when you ‘cons’ a list onto itself.  Replace the first
element of the list of four birds with a fish.  Replace the rest of that list
with a list of other fish.

#+begin_src emacs-lisp
  ;; Construct a list of four birds by evaluating several expressions with
  ;; `cons'
  (setq birds (cons 'parrot
                    (cons 'owl
                          (cons 'hummingbird
                                (cons 'finch nil)))))

  ;; `birds' points to a list of four elements
  birds ;; (parrot owl hummingbird finch)

  ;; What happens if one `cons' a list onto itself?
  (cons birds birds) ;; ((parrot owl hummingbird finch) parrot owl hummingbird
  ;; finch)

  ;; Replace the first element of the list of four birds with a fish
  (setcar birds 'salmon)

  ;; The first element of `birds' has been replaced
  birds  ;; (salmon owl hummingbird finch)

  ;; Replace the rest of `birds' with a list of other fish
  (setcdr birds '(tuna shark trout))

  ;; The second to last element of `birds' have been replaced
  birds  ;; (salmon tuna shark trout)
#+end_src

* Cutting & Storing Text
Whenever text is cut or clipped out of a buffer with a “kill” command in GNU
Emacs, it is stored in a list from which it can be brought back with a “yank”
command.

** Storing Text
When text is cut out of a buffer, it is stored on a list.  Successive pieces of
text are stored on the list successively, so the list might look like this:

#+begin_src emacs-lisp
  '("a piece of text" "previous piece")
#+end_src

The function ‘cons’ can be used to create a new list from a piece of text (an
“atom”, to use the jargon) and an existing list, like this:

#+begin_src emacs-lisp
  (cons "another piece"
        '("a piece of text" "previous piece"))
#+end_src

The ‘car’ and ‘nthcdr’ functions can be used to retrieve whichever piece of text
is required.  For instance, in the following code, ‘nthcdr 1 …’ returns the list
with the first item removed; and the ‘car’ returns the first element of that
remainder—the second element of the original list:

#+begin_src emacs-lisp
  (car (nthcdr 1 '("another piece"
                   "a piece of text"
                   "previous piece"))) ; "a piece of text"
#+end_src

The list that holds the pieces of killed text is called the “kill ring”.  This
chapter will lead up to a description of the kill ring and how it is used by
first tracing how the ‘zap-to-char’ function works.  This function calls a
function that invokes a function that manipulates the kill ring.

** ‘zap-to-char’
Let us consider the interactive ‘zap-to-char’ function.

*** The Complete ‘zap-to-char’ Implementation
The ‘zap-to-char’ function removes the text in the region between the location
of the cursor (i.e., of point) up to and including the next occurrence of a
specified character.  The text that ‘zap-to-char’ removes is put in the kill
ring; and it can be retrieved form the kill ring by typing ‘C-y’ (‘yank’).  If
the command is given an argument, it removes text through that number of
occurrences.  Thus, if the cursor were at the beginning of this sentence and the
character were ‘s’, ‘Thus’ would be removed.  If the argument were two, ‘Thus,
if the curs’ would be removed, up to and including the ‘s’ in ‘cursor’.

If the specified character is not found, ‘zap-to-char’ will say “Search failed”,
tell you the character you typed, and not remove any text.

In order to determine how much text to remove, ‘zap-to-char’ uses a search
function.

Here is the complete text of the version 22 implementation of the function:

#+begin_src emacs-lisp
  (defun zap-to-char (arg char)
    "Kill up to and including ARG'th occurrence of CHAR.
  Case is ignored if `case-fold-search' is non-nil in the current buffer.
  Goes backward if ARG is negative; error if CHAR not found."
    (interactive "p\ncZap to char: ")
    (if (char-table-p translation-table-for-input)
        (setq char (or (aref translation-table-for-input char) char)))
    (kill-region (point) (progn
                           (search-forward (char-to-string char)
                                           nil nil arg)
                           (point))))
#+end_src

*** The ‘interactive’ Expression
The interactive expression of ‘zap-to-char’ command looks like this:

#+begin_src emacs-lisp
  (interactive "p\ncZap to char: ")
#+end_src

The part within quotation marks, ‘"p\ncZap to char: "’, specifies two different
things.  First is the ‘p’.  This part is separated from the next by a newline,
‘\n’.  The ‘p’ means that the first argument to the function will be passed the
value of a “processed prefix”.  The prefix argument is passed by typing ‘C-u’
and a number, or ‘M-’ and a number.  If the function is called interactively
without a prefix, 1 is passed to this argument.

The second part of ‘"p\ncZap to char: "’ is ‘cZap to char: ’.  In this part, the
lower case ‘c’ indicates that ‘interactive’ expects a prompt and that the
argument will be a character.  The prompt follows the ‘c’ and is the string ‘Zap
to char ’.

In a read-only buffer, the ‘zap-to-char’ function copies the text to the kill
ring, but does not remove it.  The echo area displays a message saying that the
buffer is read-only.  The terminal may beep or blink.

*** The Body of ‘zap-to-char’
The body of ‘zap-to-char’ function contains the code that kills (that is,
removes) the text in the region from the current position of the cursor up to
and including the specified character.

The first part of the code looks like this:

#+begin_src emacs-lisp
  (if (char-table-p translation-table-for-input)
      (setq char (or (aref translation-table-for-input char) char)))
  (kill-region (point) (progn
                         (search-forward (char-to-string char) nil nil arg)
                         (point)))
#+end_src

‘char-table-p’ determines whether its argument is a character table.  When it
is, it sets the character passed to ‘zap-to-char’ to one of them, if that
character exists, or to the character itself.  (This is important for certain
characters in non-European languages.)

‘(point)’ is the current position of the cursor.

The next part of the code is an expression using ‘progn’.  The body of the
‘progn’ consists of calls to ‘search-forward’ and ‘point’.

*** The ‘search-forward’ Function
The ‘search-forward’ function is used to locate the zapped-for-character in
‘zap-to-char’.  If the search is successful, ‘search-forward’ leaves point
immediately after the last character in the target string.  (In ‘zap-to-char’,
the target string is just one character long.  ‘zap-to-char’ uses the function
‘char-to-string’ to ensure that the computer treats that character as a string.)
If the search is backwards, ‘search-forward’ leaves point just before the first
character in the target.  Also, ‘search-forward’ returns ‘t’ for true.  Moving
point is therefore a side effect.

In ‘zap-to-char’, the ‘search-forward’ function looks like this:

#+begin_src emacs-lisp
  (search-forward (char-to-string char) nil nil arg)
#+end_src

The ‘search-forward’ function takes four arguments:

1. The first argument is the target, what is searched for.  This must be a
   string, such as ‘"z"’.  The ‘char-to-string’ function ensures that the
   first argument fed to ‘search-forward’ is in fact a string.

2. The second argument bounds the search; it is specified as a position in the
   buffer.  In this case, the search can go to the end of the buffer, so no
   bound is set and the second argument is ‘nil’.

3. The third argument tells the function what it should do if the search
   fails—it can signal an error (and print a message) or it can return ‘nil’.  A
   ‘nil’ as the third argument causes the function to signal an error when the
   search fails.

4. The fourth argument to ‘search-forward’ is the repeat count—how many
   occurrences of the string to look for.  This argument is optional and if the
   function is called without a repeat count, this argument is passed the
   value 1.  If this argument is negative, the search goes backwards.

In template form, a ‘search-forward’ expression looks like this:

#+begin_src emacs-lisp
  (search-forward "TARGET-STRING"
                  LIMIT-OF-SEARCH
                  WHAT-TO-DO-IF-SEARCH-FAILS
                  REPEAT-COUNT)
#+end_src

*** The ‘progn’ Special Form

‘progn’ is a special form that causes each of its arguments to be evaluated in
sequence and then returns the values of the last one.  The preceding expressions
are evaluated only for the side effects they perform.  The values produced by
them are discarded.

The template of a ‘progn’ expression is very simple:

#+begin_src emacs-lisp
  (progn
    BODY...)
#+end_src

In ‘zap-to-char’, the ‘progn’ expression has to do two things: put point in
exactly the right position; and return the location of point so that
‘kill-region’ will know how far to kill to.

*** Summing up ‘zap-to-char’
The first argument to ‘kill-region’ is the position of the cursor when the
‘zap-to-char’ command is given—the value of point at the time.  Within the
‘progn’, the search function then moves point to just after the
zapped-for-character and ‘point’ returns the value of this location.  The
‘kill-region’ function puts together these two values of point, the first one as
the beginning of the region and the second as the end of the region, and removes
the region.

The ‘progn’ special form is necessary because the ‘kill-region’ command takes
two arguments; and it would fail if ‘search-forward’ and ‘point’ expressions
were written in sequence as two additional arguments.  The ‘progn’ expression is
a single argument to ‘kill-region’ and returns the one value that ‘kill-region’
needs for its second argument.

** ‘kill-region’
The ‘kill-region’ function clips text from a region and copies that text to the
kill ring, from which it may be retrieved.

The Emacs 22 version of ‘kill-region’ uses ‘condition-case’ and
‘copy-region-as-kill’, which will be detailed below.

*** The Complete ‘kill-region’ Definition
Let us consider the definition of ‘kill-region’, with comments included:

#+begin_src emacs-lisp
  (defun kill-region (beg end)
    "Kill (\"cut\") text between point and mark.
       This deletes the text from the buffer and saves it in the kill ring.
       The command \\[yank] can retrieve it from there. ... "

    ;; • Since order matters, pass point first.
    (interactive (list (point) (mark)))
    ;; • And tell us if we cannot cut the text.
    ;; 'unless' is an 'if' without a then-part.
    (unless (and beg end)
      (error "The mark is not set now, so there is no region"))

    ;; • 'condition-case' takes three arguments.
    ;;    If the first argument is nil, as it is here,
    ;;    information about the error signal is not
    ;;    stored for use by another function.
    (condition-case nil

        ;; • The second argument to 'condition-case' tells the
        ;;    Lisp interpreter what to do when all goes well.

        ;;    It starts with a 'let' function that extracts the string
        ;;    and tests whether it exists.  If so (that is what the
        ;;    'when' checks), it calls an 'if' function that determines
        ;;    whether the previous command was another call to
        ;;    'kill-region'; if it was, then the new text is appended to
        ;;    the previous text; if not, then a different function,
        ;;    'kill-new', is called.

        ;;    The 'kill-append' function concatenates the new string and
        ;;    the old.  The 'kill-new' function inserts text into a new
        ;;    item in the kill ring.

        ;;    'when' is an 'if' without an else-part.  The second 'when'
        ;;    again checks whether the current string exists; in
        ;;    addition, it checks whether the previous command was
        ;;    another call to 'kill-region'.  If one or the other
        ;;    condition is true, then it sets the current command to
        ;;    be 'kill-region'.
        (let ((string (filter-buffer-substring beg end t)))
          (when string    ;STRING is nil if BEG = END
            ;; Add that string to the kill ring, one way or another.
            (if (eq last-command 'kill-region)
                ;;    − 'yank-handler' is an optional argument to
                ;;    'kill-region' that tells the 'kill-append' and
                ;;    'kill-new' functions how deal with properties
                ;;    added to the text, such as 'bold' or 'italics'.
                (kill-append string (< end beg) yank-handler)
              (kill-new string nil yank-handler)))
          (when (or string (eq last-command 'kill-region))
            (setq this-command 'kill-region))
          nil)

      ;;  • The third argument to 'condition-case' tells the interpreter
      ;;    what to do with an error.
      ;;    The third argument has a conditions part and a body part.
      ;;    If the conditions are met (in this case,
      ;;             if text or buffer are read-only)
      ;;    then the body is executed.
      ;;    The first part of the third argument is the following:
      ((buffer-read-only text-read-only) ;; the if-part
       ;; ...  the then-part
       (copy-region-as-kill beg end)
       ;;    Next, also as part of the then-part, set this-command, so
       ;;    it will be set in an error
       (setq this-command 'kill-region)
       ;;    Finally, in the then-part, send a message if you may copy
       ;;    the text to the kill ring without signaling an error, but
       ;;    don't if you may not.
       (if kill-read-only-ok
           (progn (message "Read only text copied to kill ring") nil)
         (barf-if-buffer-read-only)
         ;; If the buffer isn't read-only, the text is.
         (signal 'text-read-only (list (current-buffer)))))))
#+end_src

*** ‘condition-case’
The most likely error incurred by the ‘kill-region’ function is to attempt to
kill a region from a read-only buffer.  The ‘kill-region’ function contains code
to handle this circumstance.  This code can be found inside a ‘condition-case’
special form.

The template for ‘condition-case’ looks like this:

#+begin_src emacs-lisp
  (condition-case
      VAR
      BODYFORM
    ERROR-HANDLER...)
#+end_src

The ‘condition-case’ special form causes the Lisp interpreter to evaluate the
code in BODYFORM.  If no error occurs, the special form returns the code’s
value and produces the side-effects, if any.

However, should an error occur, among its other actions, the function generating
the error signal will define one or more error condition names.

An error handler is the third argument to ‘condition-case’.  An error handler
has two parts, a CONDITION-NAME and a BODY.  If the CONDITION-NAME part of an
error handler matches a condition name generated by an error, then the BODY part
of the error handler is run.

The CONDITION-NAME part of an error handler may be a either a single condition
name or a list of condition names.

Also, a complete ‘condition-case’ expression may contain more than one error
handler.  When an error occurs, the first applicable handler is run.

Lastly, the first argument to the ‘condition-case’ expression, the VAR argument,
is sometimes bound to a variable that contains information about the error.
However, if the argument is ‘nil’, as is the case in ‘kill-region’, that
information is discarded.

In brief, the ‘kill-region’ function, the code ‘condition-case’ works like this:

#+begin_src quote
  IF NO ERRORS, RUN ONLY THIS CODE
        BUT, IF ERRORS, RUN THIS OTHER CODE.
#+end_src

*** Lisp macro
The part of the ‘condition-case’ expression that is evaluated in the expectation
that all goes well has a ‘when’.  A ‘when’ expression is a Lisp macro of the
form ~(when COND BODY...)~.  When ‘COND’ yields non-‘nil’, it evaluates ‘BODY’
forms sequentially and returns the value of last one, or ‘nil’ if there are
none.

The ‘kill-region’ function definition also has an ‘unless’ macro; it is the
converse of ‘when’.  The ‘unless’ macro is an ‘if’ statement without a then
clause.

In Emacs Lisp, ‘last-command’ is a variable that is set to the previous command.

**** How macros work
This section was taken from [[https://lispcookbook.github.io/cl-cookbook/macros.html][The Common Lisp Cookbook]].

In computer science, the word “macro” is used to mean a syntatic extension to a
programming language.  A macro is an ordinary piece of Lisp code that operates
on /another piece of putative Lisp code/, translating it into (a version closer
to) executable Lisp code.

Let’s work out an example.  Suppose we want a version of ‘setq’ (‘setq2’) that
sets two variables to the same value, such that the expression:

#+begin_src emacs-lisp
  (setq2 v1 v2 e)
#+end_src

binds the result of evaluating the form ‘e’ to the symbols ‘v1’ and ‘v2’.  The
problem with defining such a function is that there is no way to tell the
interpreter which variables are supposed to be set.  What we aim for is to have
the interpreter expanding that form into:

#+begin_src emacs-lisp
  (progn
    (setq v1 e)
    (setq v2 e))
#+end_src

A macro allows us to achieve precisely this, by specifying a program for
transforming the input pattern ~(setq2 v1 v2 e)~ into the output pattern ~(progn
…)~.  Here is a definition of the ‘setq2’ macro:

#+begin_src emacs-lisp
  (defmacro setq2 (v1 v2 e)
    (list 'progn
          (list 'setq v1 e)
          (list 'setq v2 e)))
#+end_src

Then it returns a piece of code.  In Lisp, because code is represented as lists,
we can simply return a list that /represents/ code.

Each /quoted/ symbol evaluates to itself, i.e., it is returned as is:

+ ~(quote foo bar baz)~ returns ~(foo bar baz)~.
+ The quote character, ~'~, is a shortcut to ~quote~, a /special operator/.
+ So, ~'foo~ evaluates to ~foo~.

So, our macro returns:

+ The symbol ~progn~;
+ A second list, that contains:
  - The symbol ~setq~;
  - The variable ~v1~ (note that the variable is /not/ evaluated inside the
    macro); and
  - The expression ~e~ (not evaluated either).
+ A third list, which mirrors the second for the variable ~v2~.

To check what code a macro would expand to, use the function ‘macroexpand’:

#+begin_src emacs-lisp
  (macroexpand '(setq2 v1 v2 3))
#+end_src

#+RESULTS:
| progn | (setq v1 3) | (setq v2 3) |

More interestingly:

#+begin_src emacs-lisp
  (macroexpand '(setq2 v1 v2 (+ z 3)))
#+end_src

#+RESULTS:
| progn | (setq v1 (+ z 3)) | (setq v2 (+ z 3)) |
** ‘copy-region-as-kill’
The ‘copy-region-as-kill’ function copies a region of text from a bufer and (via
either ‘kill-append’ of ‘kill-new’) saves it in the ‘kill-region’.

**** Complete ‘copy-region-as-kill’ Function Definition
Here is the complete text of the version 22 ‘copy-region-as-kill’ function:

#+begin_src emacs-lisp
  (defun copy-region-as-kill (beg end)
    "Save the region as if killed, but don't kill it.
       In Transient Mark mode, deactivate the mark.
       If `interprogram-cut-function' is non-nil, also save the text for a window system cut and paste."
    (interactive "r")
    (if (eq last-command 'kill-region)
        (kill-append (filter-buffer-substring beg end) (< end beg))
      (kill-new (filter-buffer-substring beg end)))
    (if transient-mark-mode
        (setq deactivate-mark t))
    nil)
#+end_src

Once the mark is set, a buffer always contains a region.  Transient Mark mode
can be activated to highlight the region temporarily.

Also, a windowing system allows for copying, cutting, and pasting of text among
different programs.  In the X windowing system, for example, the
‘interprogram-cut-function’ function is ‘x-select-text’, which works with the
system’s equivalent of the Emacs kill ring.

**** The body of ‘copy-region-as-kill’
Like ‘kill-region’, the ‘copy-region-as-kill’ function makes use of the
‘last-command’ variable that keeps track of the previous Emacs command.

***** ‘last-command’ and ‘this-command’
The ‘eq’ function tests whether its first argument is the same Lisp object as
its second argument.  The ‘eq’ function is similar to the ‘equal’ function in
that it determines whether two representations are actually the same object
inside the computer, but with different names.  The ‘equal’ function determines
whether the structure and contents of two expressions are the same.

***** The ‘kill-append’ function
The ‘kill-append’ function looks like this:

#+begin_src emacs-lisp
  (defun kill-append (string before-p &optional yank-handler)
    "Append STRING to the end of the latest kill in the kill ring.
       If BEFORE-P is non-nil, prepend STRING to the kill.
       ... "
    (let* ((cur (car kill-ring)))
      (kill-new (if before-p (concat string cur) (concat cur string))
                (or (= (length cur) 0)
                    (equal yank-handler
                           (get-text-property 0 'yank-handler cur)))
                yank-handler)))
#+end_src

***** The ‘kill-new’ function
In version 22 of Emacs, the ‘kill-new’ function looks like this:

#+begin_src emacs-lisp
  (defun kill-new (string &optional replace yank-handler)
    "Make STRING the latest kill in the kill ring.
       Set `kill-ring-yank-pointer' to point to it.

       If `interprogram-cut-function' is non-nil, apply it to STRING.
       Optional second argument REPLACE non-nil means that STRING will replace
       the front of the kill ring, rather than being added to the list.
       ..."
    (if (> (length string) 0)
        (if yank-handler
            (put-text-property 0 (length string)
                               'yank-handler yank-handler string))
      (if yank-handler
          (signal 'args-out-of-range
                  (list string "yank-handler specified for empty string"))))
    (if (fboundp 'menu-bar-update-yank-menu)
        (menu-bar-update-yank-menu string (and replace (car kill-ring))))
    (if (and replace kill-ring)
        (setcar kill-ring string)
      (push string kill-ring)
      (if (> (length kill-ring) kill-ring-max)
          (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
    (setq kill-ring-yank-pointer kill-ring)
    (if interprogram-cut-function
        (funcall interprogram-cut-function string (not replace))))
#+end_src

The conditional test is ~(and replace kill-ring)~.  This will be true when two
conditions are met: the kill ring has something in it, and the ‘replace’
variable is non-‘nil’.

When the ‘kill-append’ function sets ‘replace’ to be true and when the kill ring
has at least one item in it, the ‘setcar’ expression is executed:

#+begin_src emacs-lisp
  (setcar kill-ring string)
#+end_src

The ‘setcar’ function actually changes the first element of the ‘kill ring’ list
to the value of ‘string’.  It replaces its first element.

On the other hand, if the kill ring is empty, or if ~replace~ is nil, the
else-part of the condition is executed:

#+begin_src emacs-lisp
  (push string kill-ring)
#+end_src

‘push’ adds its first argument onto the second.  It is morally equivalent to:

#+begin_src emacs-lisp
  (setq kill-ring (cons string kill-ring))
#+end_src

or the more modern:

#+begin_src emacs-lisp
  (add-to-list kill-ring string)
#+end_src

The second part of the ‘if’ clause keeps the kill ring from growing too long.
It looks like this:

#+begin_src emacs-lisp
  (if (> (length kill-ring) kill-ring-max)
      (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))
#+end_src

The ‘fboundp’ function returns non-‘nil’ if the symbol it is probing has a function
definition that is not void.

** Digression into C
The ‘delete-and-extract-region’ function deletes text between a START and END
point and returns is.  It is written in C and is one of the primitives of the
GNU Emacs system.

** Initializing a Variable with ‘defvar’
In Emacs Lisp, a variable such as the ‘kill-ring’ is created and given an
initial value by using the ‘defvar’ special form.

The ‘defvar’ special form is similar to ‘setq’ in that it sets the value of a
variable.  It is unlike ‘setq’ in two ways: first, it only sets the value of the
variable if the variable does not already have a value.  If the variable already
has a value, ‘defvar’ does not override the existing value.  Second, ‘defvar’
has a documentation string.

*** See the Current Value of a Variable
The current value of a variable can be enquired by the ‘describe-variable’
function (‘C-h v’).

*** ‘defvar’ and an asterisk
For variables susceptible to user customization, ‘defcustom’ is more suited than
‘defvar’.  The signal a variable can be changed by a user with ‘defvar’, add an
asterisk to the first column of its documentation string:

#+begin_src emacs-lisp
(defvar shell-command-default-error-buffer nil
       "*Buffer name for `shell-command' ... error output.
     ... ")
#+end_src

** Review
Here is a summary of newly introduced functions in the last couple chapter.

*** ‘car’ & ‘cdr’
‘car’ evaluates to the first element of a list; ‘cdr’ evaluates to all but the
first element of a list.

*** ‘cons’
‘cons’ constructs a list by prepending its first argument to its second
argument.

*** ‘funcall’
‘funcall’ evaluates its first argument as a function.  It passes its remaining
arguments to the evaluated function.

*** ‘nthcdr’
Evaluates to the Nth iteration of ‘cdr’ on a list.  The “rest of the rest”, as
it were.

*** ‘setcar’ & ‘setcdr’
‘setcar’ sets the first element of a list; ‘setcdr’ sets all but the first
element of a list.

*** ‘progn’
Evaluate each argument in sequence and return the value of the last.

*** ‘save-restriction’
Record whatever narrowing is in effect in the current buffer, if any, and
restore that narrowing after evaluating the arguments.

*** ‘search-forward’
Search for a string, and if the string is found, move point.

*** ‘kill-region’, ‘delete-and-extract-region’ & ‘copy-region-as-kill’
‘kill-region’ cuts the text between point and mark from the buffer and stores
that text in the kill ring, so you can get it back by yanking.

‘copy-region-as-kill’ copies the text between point and mark into the kill-ring,
from which it can be retrieved by yanking.  The function does not cut or remove
the text from the buffer.

‘delete-and-extract-region’ removes the text between point and mark from the
buffer and throws it away.  It cannot be retrieved.  (This is not an interactive
command.)

** Searching Exercises
*** Exercise 8.1
Write an interactive function that searches for a string.  If the search finds
the string, leave point after it and display a message that says, “Found!”.
Name it ‘test-search’.

#+begin_src emacs-lisp
  (defun gtms-test-search (string)
    "Search for STRING in current buffer.

     If found, message \"Found!\", and move point after occurence.
     Otherwise, message \"Not found.\", and do not move point."
    (interactive "sSearch for: ")
    (let ((search-pos
           (save-excursion
             (progn
               (goto-char (point-min))
               (search-forward string nil t)))))
      (if search-pos
          (progn
            (message "\"%s\" found in the buffer!" string)
            (goto-char search-pos))
        (message "\"%s\" not found in the buffer." string))))
#+end_src

*** Exercise 8.2
Write a function that prints the third element of the kill ring in the echo
area, if any; if the kill ring does not contain a third element, print an
appropriate message.

#+begin_src emacs-lisp
  (defun gtms-third-element-kill-ring ()
    "Print the third element of the `kill-ring' in the echo area.
  
  If there are less than three elements in the `kill-ring', produce a warning."
    (interactive)
    (if (< (length kill-ring) 3)
        (message "There are less than three elements in the `kill-ring'!")
      (message "The third element of the `kill-ring' is `%s'"
               (substring-no-properties (nth 2 kill-ring)))))
#+end_src

* List Implementation
Lists are stored using a series of pairs of pointers.  In the series, the first
pointer in each pair points to the next pair, or to the symbol ‘nil’, which
marks the end of the list.  A pointer itself is the electronic address of what
is pointed to.  Hence, a list is kept as a series of electronic addresses.

** Lists Diagrammed
For example, the list ‘(rose violet buttercup)’ has three elements,
‘rose’, ‘violet’, and ‘buttercup’.  In the computer, the electronic
address of ‘rose’ is recorded in a segment of computer memory along with
the address that gives the electronic address of where the atom ‘violet’
is located; and that address (the one that tells where ‘violet’ is
located) is kept along with an address that tells where the address for
the atom ‘buttercup’ is located.

This sounds more complicated than it is and is easier seen in a diagram:

#+begin_src ditaa
         ___ ___      ___ ___      ___ ___
        |___|___|--> |___|___|--> |___|___|--> nil
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup
#+end_src

When a variable is set to a list with a function such as ‘setq’, it stores the
address of the first element in the variable.  Thus, evaluation of the
expression:

#+begin_src emacs-lisp
  (setq bouquet '(rose violet buttercup))
#+end_src

creates the following set of pointers:

#+begin_src ditaa
     bouquet
      |
      |    --------------       ---------------       ----------------
      |   | car   | cdr  |     | car    | cdr  |     | car     | cdr  |
       -->| rose  |   o------->| violet |   o------->| butter- |  nil |
          |       |      |     |        |      |     | cup     |      |
           --------------       ---------------       ----------------
#+end_src

Interestingly, the evaluation of the following expression:

#+begin_src emacs-lisp
  (setq flowers (cdr bouquet))
#+end_src

produces the following:

#+begin_src ditaa
     bouquet        flowers
       |              |
       |     ___ ___  |     ___ ___      ___ ___
        --> |   |   |  --> |   |   |    |   |   |
            |___|___|----> |___|___|--> |___|___|--> nil
              |              |            |
              |              |            |
               --> rose       --> violet   --> buttercup
#+end_src

** Symbols as a Chest of Drawers
Symbols can be be represented as a chest of drawers.  Drawers contain pointers
(directions) to each of its composing elements, namely:

+ pointer to symbol name;
+ pointer to symbol definition;
+ pointer to variable value; and
+ pointer to property list.

** Exercise
Set ‘flowers’ to ‘violet’ and ‘buttercup’.  Cons two more flowers to this list
and set this new list to ‘more-flowers’.  Set the CAR of ‘flowers’ to a fish.
What does the ‘more-flowers’ list now contain?

#+begin_src emacs-lisp
  ;; Set `flowers' to `violet' and `buttercup'
  (setq flowers '(violet buttercup))

  ;; Cons two more flowers to this list and set the new list to `more-flowers'
  (setq more-flowers (cons 'jasmine (cons 'rose flowers)))

  ;; Set the car of flowers to a fish
  (setcar flowers 'goldfish)

  ;; What does the more-flowers now contain?
  more-flowers ;; (jasmine rose goldfish buttercup)
#+end_src

* Yanking
The interactive ‘yank’ command (‘C-y’) is used to retrieve text back from the
kill ring into the position at point.  Should a ‘C-y’ command be immediately
followed by a ‘M-y’ command (‘yank-pop’), the first element of the kill ring is
replaced by the second element; successive invocations of ‘yank-pop’ replace the
yanked text by the next element in the kill ring.  When the last element of the
kill ring is reached, the next ‘yank-pop’ invocation brings back the first
ocurrence in the kill ring and the cycle is repeated (hence the “kill ring”).

** Kill Ring Overview
The kill ring is a list of textual strings.

Three functions are used for bringing text back from the kill ring: ‘yank’,
which is bound to ‘C-y’ by default; ‘yank-pop’, which is bound to ‘M-y’ by
default; and ‘rotate-yank-pointer’, which is used by the two other functions.

These functions refer to the kill ring through a variable called the
‘kill-ring-yank-pointer’.  Indeed, the insertion code for both the ‘yank’ and
‘yank-pop’ function was, up to Emacs 22:

#+begin_src emacs-lisp
  (insert (car kill-ring-yank-pointer))
#+end_src

** The ‘kill-ring-yank-pointer’ Variable
The ‘kill-ring-yank-pointer’ is documented as “the tail of the kill ring whose
car is the last thing yanked”.

Interestingly, while both variables ‘kill-ring’ and ‘kill-ring-yank-pointer’ are
/pointers/, inasmuch as they each point to elements of a cons cell (that may be
part of a list), while the former is usually invoked to refer to the /list/ it
points to, the latter is usually invoked for the /position/ it points to in a
list.

** Exercises with ‘yank’ and ‘nthcdr’
*** Exercise 10.1
Using ‘C-h v’ (‘describe-variable’), look at the value of your kill ring.  Add
several items to your kill ring; look at its value again.  Using ‘M-y’
(‘yank-pop’), move all the way around the kill ring.  How many items were there
in your kill ring?  Find the value of ‘kill-ring-max’.  Was your kill ring full,
or could you have kept more blocks of text within it?

#+begin_src emacs-lisp
  kill-ring-max ; 60
#+end_src

*** Exercise 10.2
Using ‘nthcdr’ and ‘car’, construct a series of expressions to return the first,
second, third, and fourth elements of a list.

#+begin_src emacs-lisp
  ;; Define list LST
  (setq lst '(one two three four five six))

  ;; Generalize an expression to return the first to the fourth element in list
  ;; LST
  (car (nthcdr 0 lst)) ; one
  (car (nthcdr 1 lst)) ; two
  (car (nthcdr 2 lst)) ; three
  (car (nthcdr 3 lst)) ; four
#+end_src

* Loops & Recursion
Emacs Lisp has two primary ways to evaluate one or more expressions repeatedly:
one uses a ‘while’ loop, and the other uses “recursion”.

** ‘while’
The template for a ‘while’ expression is as follows:

#+begin_src emacs-lisp
  (while TRUE-OR-FALSE-TEST
    BODY...)
#+end_src

*** Looping with ‘while’
The craft of writing a ‘while’ loop consists of choosing a mechanism such that
the true-or-false-test returns true just the number of times that one wants the
subsequent expressions to be evaluated, and then have the test return ‘nil’.
This means that a ‘while’ expression will /always/ return ‘nil’; it is evaluated
for the side effects enclosed in its body form.

*** A ‘while’ Loop and a List
A template for a ‘while’ loop that uses the ‘cdr’ function repeatedly to cause
the true-or-false-test to eventually fail would look like this:

#+begin_src emacs-lisp
  (while TEST-WHETHER-LIST-IS-EMPTY
    BODY...
    SET-LIST-TO-CDR-OF-LIST)
#+end_src

*** An Example: ‘print-elements-of-list’
the ‘print-elements-of-list’ function illustrates a ‘while’ loop with a list:

#+begin_src emacs-lisp
  (defun print-elements-of-list (list)
    "Print each element of LIST on a line of its own."
    (while list
      (print (car list))
      (setq list (cdr list))))
#+end_src

Now, evaluating the function with a list fed to it results in printing each
element of the list in its own line in the minibuffer; when the last iteration
of ‘while’ is ran, the function then returns ‘nil’:

#+begin_src emacs-lisp
  (setq animals '(gazelle giraffe lion tiger))

  (print-elements-of-list animals)
#+end_src

*** A Loop with an Incrementing Counter
Another way to control the number of iterations of a ‘while’ loop is to write
the first argument as a test that returns false when the desired number of
repetitions is complete.  This requires a counter—an expression that keeps track
of how many times the loop repeats itself.

*** Details of an Incrementing Loop
The template for a ‘while’ loop controlled by an incrementing counter would look
like this:

#+begin_src emacs-lisp
  SET-COUNT-TO-INITIAL-VALUE
  (while (< count desired-number)       ; true-or-false-test
    BODY...
    (setq count (1+ count)))            ; incrementer
#+end_src

Here is an example of a function employing a ‘while’ loop to compute the sum of
all integers between two given numbers:

#+begin_src emacs-lisp
  (defun gtms-sum-numbers-in-interval (first last)
    "Returns the sum of all numbers between FIRST and LAST."
    (let ((result first)
          (accumulator (1+ first)))
      (while (<= accumulator last)
        (setq result (+ result accumulator))
        (setq accumulator (1+ accumulator)))
      result))
#+end_src

**** Incrementing Example
We will consider two case scenarios to compute the sum of a list of consecutive
natural numbers (say, from one to seven):

1. Starting with the smallest number, and add up the list in sequence;
2. Starting with the largest number and add the list down.

**** The Parts of the Function Definition
The ‘gtms-sum-numbers-in-interval’ starts by locally binding two variables: the
‘results’ variable is initially bound to the the first number in the interval;
and the ‘accumulator’ variable is bound to the following number.  The ‘result’
variable will incrementally hold the cumulative sum of all numbers in the
interval.  The ‘accumulator’ variable will both serve as the summand term to be
added to the result over each iteration and as the counter that tracks when to
exit the ‘while’ loop.

The ‘while’ loop ensues.  For each iteration of the ‘while’ loop, the ‘result’
variable is updated by adding to it the current value of ‘accumulator’.  The
value of ‘accumulator’ is then incremented by one, prompting the next iteration
of the loop.  These steps will repeat, adding each successive number until
‘accumulator’ exceeds the last number (controlled by the ‘while’ test ~(<=
accumulator last)~), at which point the program exits the loop.

Once the ‘while’ loop is concluded, the value of ‘result’ is evaluated and
returned, as the cumulative sum of all numbers between the two provided
arguments.

**** Putting the Function Definition Together
In outline, the function will look like this:

#+begin_src emacs-lisp
  (defun NAME-OF-FUNCTION (ARGUMENT-LIST)
    "DOCUMENTATION..."
    (let (VARLIST)
      (while (TRUE-OR-FALSE-TEST)
        BODY-OF-WHILE...)
      ...))                             ; Need final expression here.
#+end_src

*** Loop with a Decrementing Counter
Alternatively, the ‘while’ loop could be written so that the test determines
whether a counter is greater than zero.  The template of a decrementing ‘while’
loop looks like this:

#+begin_src emacs-lisp
  (while (> counter 0)                  ; true-or-false-test
    BODY...
    (setq counter (1- counter)))        ; decrementer
#+end_src

**** Decrementing Example
Here is the ‘gtms-sum-numbers-in-interval’ written with a decrementer loop:

#+begin_src emacs-lisp
  (defun gtms-sum-numbers-in-interval-decrement (first last)
    "Returns the sum of all numbers between FIRST and LAST."
    (let ((result last)
          (decrementer (1- last)))
      (while (>= decrementer first)
        (setq result (+ result decrementer))
        (setq decrementer (1- decrementer)))
      result))
#+end_src

**** The Parts of the Function Definition
There are two differences between the decrement function definition and the
original one.  The first concerns the starting point: instead of adding numbers
up from the first number in the interval, we begin by adding the last number to
the second to last, all the way down to the first number.  Consequentely, we
replace the ‘accumulator’ variable by a ‘decrementer’ variable, which will both
serve as the summand to update the ‘results’ variable, and as the tracker of
when to exit the ‘while’ loop.  The ‘while’ loop will terminate when the
condition ~(>= decrementer first)~ yields ‘nil’.

**** Putting the Function Definition Together
In brief, a properly written ‘while’ loop will consist of three parts:

1. A test that returns false after the loop as repeated the intended number of
   times.

2. An expression that, when evaluated the intended number of times, will return
   the desired result.

3. An expression to update the value passed to the true-or-false-test so that
   the test fails once the loop has repeated itself the intended number of
   times.

** Save Your Time: ‘dolist’ and ‘dotimes’
‘dolist’ and ‘dotimes’ are lisp macros that also provide for looping
functionality.

*** The ‘dolist’ Macro
To reverse a list, one can use the ‘reverse’ function, such like this:

#+begin_src emacs-lisp
  (setq animals '(gazelle giraffe lion tiger))

  (reverse animals)  ;; (tiger lion giraffe gazelle)
#+end_src

The same can be achieved with a ‘while’ loop:

#+begin_src emacs-lisp
  (defun reverse-list-with-while (list)
    "Using `while', reverse the order of LIST."
    (let (value)                        ; make sure list starts empty
      (while list
        (setq value (cons (car list) value))
        (setq list (cdr list)))
      value))

  (reverse-list-with-while animals) ;; (tiger lion giraffe gazelle)
#+end_src

And here is how the ‘dolist’ macro would work to the same effect:

#+begin_src emacs-lisp
  (defun reverse-list-with-dolist (list)
    "Using `dolist', reverse the order of LIST."
    (let (value)                        ; make sure list starts empty
      (dolist (element list value)
        (setq value (cons element value)))))

  (reverse-list-with-dolist animals) ;; (tiger lion giraffe gazelle)
#+end_src

The ‘dolist’ macro has the form:

#+begin_src emacs-lisp
  (dolist (VAR LIST [RESULT])
    BODY...)
#+end_src

The ‘dolist’ sexp will loop over LIST, evaluating BODY with VAR bound to each
CAR from LIST, in turn.  Then, it evaluates RESULT to get the returned value
(defaulting to ‘nil’).

*** The ‘dotimes’ Macro
The ‘dotimes’ macro is similar to ‘dolist’, except that it loops a predefined
number of times.

For example, the following binds the numbers zero up to, but not including, the
number three to the first argument, NUMBER, and then constructs a list of the
three numbers.

#+begin_src emacs-lisp
  (let (value)
    (dotimes (number 3 value)
      (setq value (cons number value)))) ;; (2 1 0)
#+end_src

The ‘dotimes’ macro has the form:

#+begin_src emacs-lisp
  (dotimes (VAR COUNT [RESULT])
    BODY...)
#+end_src

The ‘dotimes’ s-exp evaluates the BODY form with VAR bound to successive
integers from 0, inclusive, to COUNT, exclusive.  Then it evaluates RESULT to
get the returned value (defaulting to ‘nil’).

** Recursion
A recursive function contains code that tells the Lisp interpreter to call a
program that runs exactly like itself, but with slightly different arguments.
Each iteration of the code ran, while formally identical, represents a
unique instance of the code.

*** Building Robots: Extending the Metaphor
A recursive function is a function that calls itself, causing the Lisp
interpreter to run a different function with the same name that does the same
job as the first, but with different arguments.  it is important that the
arguments differ from one instance to the next; otherwise, the process will
never stop.

*** Parts of a Recursive Definition
A recursive function typically contains a conditional expression which has three
parts:

1. A true-or-false-test that determines whether the function is called again,
   here called the “do-again-test”.

2. The name of the function.  When this name is called, a new instance of the function.

3. An expression that returns a different value each time the function is
   called, here called the “next-step-expression”.  Consequentely, the
   argument(s) passed to the new instance of the function will be different from
   that passed to the previous instance.  This causes the conditional
   expression, the “do-again-test”, to test false after the intended number of
   repetitions.

A simple recursive pattern would look like this:

#+begin_src emacs-lisp
  (defun NAME-OF-RECURSIVE-FUNCTION (ARGUMENT-LIST)
    "DOCUMENTATION..."
    (if DO-AGAIN-TEST
        BODY...
      (NAME-OF-RECURSIVE-FUNCTION
       NEXT-STEP-EXPRESSION)))
#+end_src

*** Recusion with a List
Here is an example of a function that prints the elements of a list using
recursion:

#+begin_src emacs-lisp
  (setq animals '(gazelle giraffe lion tiger))

  (defun print-elements-recursively (list)
    "Print each element of LIST on a line of its own.
  Uses recursion."
    (when list                          ; do-again-test
      (print (car list))                ; body
      (print-elements-recursively       ; recursive call
       (cdr list))))                    ; next-step-expression

  (print-elements-recursively animals)
#+end_src

*** Recursion in Place of a Counter
The ‘gtms-sum-numbers-in-interval’ function can also be written recursively:

#+begin_src emacs-lisp
  (defun gtms-sum-numbers-in-interval-recursively (first last)
        "Returns the sum of all numbers between FIRST and LAST."
        (let ((result first)
              (accumulator (1+ first)))
          (if (> accumulator last)
              result
            (+ result
               (gtms-sum-numbers-in-interval-recursively
                accumulator last)))))
#+end_src

Note that the recursive form makes use of the previously defined ‘accumulator’
variable to place a summation call from the /subsequent/ number to ‘first’ up to
the ‘last’ on the stack.  This will iteratively place increasingly shallower
calls to the function onto the stack until ‘accumulator’ exceeds ‘last’.  At
this point, ‘result’ will be bound to ‘last’ itself (for the innermost call on
the stack will take the form ~(gtms-sum-numbers-in-interval-recursively last
last)~).  This value of ‘result’ will then be fed to the call seeking the
addition of the second to last element in the interval and the ‘last’ one.  The
value of ‘result’ will be concomitantly updated, and each previous number will
be added to it as each stack call becomes solved—up until the original call.
This means that this recursive formulation computes the sum /backwards/, from
the ‘last’ to the ‘first’ number.

*** Recursion Example Using ‘cond’
The template of a ‘cond’ expression looks like this:

#+begin_src emacs-lisp
  (cond
   CLAUSES...)
#+end_src

where each CLAUSE looks like ~(CONDITION BODY…)~.  The CONDITION is evaluated
and, if the value is non-nil, the clause succeeds: the expressions in BODY are
then evaluated and the last one’s value is the value of the ‘cond’ form.

If a clause has one element, as in ~(CONDITION)~, then the ‘cond’ form returns
CONDITION’s value, if that is non-nil.  If no clause succeeds, the ‘cond’ form
returns ‘nil’.

Written using a ‘cond’ form, the ‘gtms-sum-numbers-in-interval’ function would
look like this:

#+begin_src emacs-lisp
  (defun gtms-sum-numbers-in-interval-using-cond (first last)
    "Returns the sum of all numbers between FIRST and LAST."
    (let ((result first)
          (accumulator (1+ first)))
      (cond ((> accumulator last) result)
            ((<= accumulator last)
             (+ result
                (gtms-sum-numbers-in-interval-using-cond
                 accumulator last))))))
#+end_src

In this example, the ‘cond’ form returns the value of ‘result’ when
‘accumulator’ first exceeds ‘last’; otherwise, it proceeds to recursively call
the function with ‘accumulator’ in place of ‘first’.

*** Recursive Patterns
Following are three common recursive patterns involving lists.

**** Recursive Pattern: ‘every’
In the ‘every’ recursive pattern, an action is performed in every element of a
list.

The pattern is:

+ If a list is empty, return ‘nil’.
+ Else, act on the CAR of the list:
  - through a recursive call by the function on the CDR of the list;
  - and, optionally, combine the acted on element, using ‘cons’, with the
    results of acting on the rest.

Here is an example:

#+begin_src emacs-lisp
  (defun square-each (numbers-list)
    "Square each of a NUMBERS LIST, recursively."
    (if (not numbers-list)
        nil
      (cons
       (* (car numbers-list)
          (car numbers-list))
       (square-each (cdr numbers-list)))))

  (square-each '(1 2 3)) ;; (1 4 9)
#+end_src

**** Recursive Pattern: ‘accumulate’
In the ‘accumulate’ recursive pattern, an action is performed on every element
of a list and the result of that action is accumulated with the results of
performing the action on the other elements.

The pattern is:

+ If a list is empty, return zero of some other constant.
+ Else, act on the CAR of the list:
  - and combine that acted-on element (with a combining function) with
  - a recursive call by the function on the CDR of the list.

Here is an example:

#+begin_src emacs-lisp
  (defun add-elements (numbers-list)
    "Add the elements of NUMBERS-LIST together."
    (if (not numbers-list)
        0
      (+ (car numbers-list)
         (add-elements (cdr numbers-list)))))

  (add-elements '(1 2 3 4)) ; 10
#+end_src

**** Recursive Pattern: ‘keep’
In the ‘keep’ recursive pattern, each element of a list is tested; the element
is acted on and the results are kept only if the element meets a criterion.

The pattern is:

+ If a list is empty, return ‘nil’.
+ Else, if the CAR of the list passes a test:
  - act on that element and combine it, using ‘cons’ with
  - a recursive call by the function on the CDR of the list.
+ Otherwise, if the CAR of the list fails the test:
  - skip on that element, and
  - recursively, call the function on the CDR of the list.

Here is an example with ‘cond’:

#+begin_src emacs-lisp
  (defun keep-three-letter-words (word-list)
    "Keep three letter words in WORD-LIST."
    (cond
     ;; First do-again-test: stop-condition
     ((not word-list) nil)

     ;; Second do-again-test: when to act
     ((eq 3 (length (symbol-name (car word-list))))
      ;; combine acted-on element with recursive call on shorter list
      (cons (car word-list) (keep-three-letter-words (cdr word-list))))

     ;; Third do-again-test: when to skip element;
     ;; recursively call shorter list with next-step expression
     (t (keep-three-letter-words (cdr word-list)))))

  (keep-three-letter-words '(one two three four five six)) ;; (one two six)
#+end_src

*** Recursion without Deferments
By design, recursive functions will defer the computation of the first
instantiation until the second is returned, which in turn will be deferred until
all the inner instantiations are completed.  This may severely tax computational
resources (potentially leading, in Emacs Lisp, to C core dumps).

*** No Deferment Solution
In order to prevent deferred operations, one can write to a patternu that
involves writing two function definitions, an initialization function and a
helper function.  The initialization function sets up the job; the helper
function does the job.

Here is an example:

#+begin_src emacs-lisp
  (defun triangle-initialization (number)
    "Return the sum of the numbers 1 through NUMBER inclusive.
  This is the initialization component of a two function duo that uses recursion."
    (triangle-recursive-helper 0 0 number))

  (defun triangle-recursive-helper (sum counter number)
    "Return SUM, using COUNTER, through NUMBER inclusive.
  This is the helper component of a two function duo that uses recursion."
    (if (> counter number)
        sum
      (triangle-recursive-helper (+ sum counter) ; sum
                                 (1+ counter)    ; counter
                                 number)))       ; number

  (triangle-initialization 2) ; 3
#+end_src

** Looping Exercises
*** Exercise 11.1
Write a function similar to ‘triangle’ in which each row has a value which is a
square of the row number.  Use a ‘while’ loop.

#+begin_src emacs-lisp
  (defun gtms-squared-triangle (number-of-rows)
    "Add the square of the number of pebbles in each row of a triangle with NUMBER-OF-ROWS.
  The first row has one pebble, the second row two pebbles, the
  third row three pebbles, and so on."
    (let ((total 0)
          (row-number 1))
      (while (<= row-number number-of-rows)
        (setq total (+ total (* row-number row-number)))
        (setq row-number (1+ row-number)))
      total))

  (gtms-squared-triangle 4) ; 30
  (gtms-squared-triangle 7) ; 140
#+end_src

*** Exercise 11.2
Write a function similar to ‘triangle’ that multiplies instead of adding the
values.

#+begin_src emacs-lisp
  (defun gtms-multiplied-triangle (number-of-rows)
    "Multiply the number of pebbles in each row of a triangle with NUMBER-OF-ROWS.
  The first row has one pebble, the second row two pebbles,
  the third row three pebbles, and so on."
    (let ((total 1)
          (row-number 1))
      (while (<= row-number number-of-rows)
        (setq total (* total row-number))
        (setq row-number (1+ row-number)))
      total))

  (gtms-multiplied-triangle 4)
  (gtms-multiplied-triangle 7) ; 5040
#+end_src

*** Exercise 11.3
Rewrite these functions recursively.  Rewrite these functions using ‘cond’.

**** Squared Triangle
#+begin_src emacs-lisp
(defun gtms-squared-triangle-init (number-of-rows)
  "Add the square of the number of pebbles in each row of a triangle with NUMBER-OF-ROWS.
The first row has one pebble, the second row two pebbles, the
third row three pebbles, and so on."
  (gtms-squared-triangle-helper 0 1 number-of-rows))

(defun gtms-squared-triangle-helper (sum counter number-of-rows)
  (cond ((> counter number-of-rows) sum)
        ((<= counter number-of-rows)
         (gtms-squared-triangle-helper (+ sum (* counter counter))
                                  (1+ counter)
                                  number-of-rows))))
#+end_src

**** Multiplied Triangle
#+begin_src emacs-lisp
  (defun gtms-multiplied-triangle-init (number-of-rows)
    "Multiply the number of pebbles in each row of a triangle with NUMBER-OF-ROWS.
  The first row has one pebble, the second row two pebbles, the
  third row three pebbles, and so on."
    (gtms-multiplied-triangle-helper 1 1 number-of-rows))

  (defun gtms-multiplied-triangle-helper (product counter number-of-rows)
    (cond ((> counter number-of-rows) product)
          ((<= counter number-of-rows)
           (gtms-multiplied-triangle-helper (* product counter)
                                            (1+ counter)
                                            number-of-rows))))
#+end_src

*** Exercise 11.4
Write a function for Texinfo mode that creates an index entry at the beginning
of a paragraph for every ‘@dfn’ within the paragraph.  (In a Texinfo file,
‘@dfn’ marks a definition.)

(Answer taken from [[https://github.com/RenWenshan/emacs-lisp-intro-solutions/blob/master/ch11.el][here]].)

#+begin_src emacs-lisp
  (defun gtms-create-index-for-dfn ()
    "Create an index entry at the beginning of the paragraph for every `@dfn'."
    (interactive)
    (save-excursion
      (mark-paragraph)
      (save-restriction
        (narrow-to-region (point) (mark))
        (let (dfns)
          (while (search-forward "@dfn" nil t)
            (when (search-forward "{" nil t)
              (let ((start (point)))
                (when (search-forward "}" nil t)
                  (forward-char -1)
                  (let ((end (point)))
                    (setq dfns (cons (buffer-substring start end)
                                     dfns)))))))
          (forward-paragraph -1)
          (dolist (dfn (reverse dfns))
            (insert (concat "@cindex " dfn "\n")))))))
#+end_src

* Regexp Search
Regular expression searches are described in [[info:emacs#Regexps][Regular Expression Search]] (Emacs)
as well as in [[info:elisp#Regular Expressions][Regular Expressions]] (elisp).  The [[https://www.emacswiki.org/emacs/RegularExpression][Emacs wiki entry on regular
expressions]] is also a valuable resource to understand regexps in Emacs.  This
[[https://www.youtube.com/watch?v=TxYGHjKBMUg][video by Protesilaos Stavrou]] higlights some very unique built-in functionality
to perform text surgery in Emacs with regexps, namely the use of Emacs functions
to manipulate text on string sets in regular expressions.

** The Regular Expression for ‘sentence-end’
The symbol ‘sentence-end’ is bound to the pattern that marks the end of a
sentence.

#+begin_src emacs-lisp
    (sentence-end)" ; \\([.?!…‽][]\"'”’)}]*\\($\\|[  ]$\\|	\\|[  ][  ]\\)\\|[。．？！]+\\)[  	
  ]*"
#+end_src

Two backslashes are required to escape a character in a regular expression in
Emacs Lisp.  The first backslash quotes the following backslash; and the second
indicates that the following character, is special.

** The ‘re-search-forward’ Function
The ‘re-search-forward’ function searches forward for a regular expression
REGEXP.  Like ‘search-forward’, the ‘re-search-forward’ function takes four
arguments:

1. The first argument is the regular expression REGEXP that the function
   searches for.  The regular expression will be a string between quotation
   marks.

2. The optional second argument, BOUND, limits how far the function will search;
   it is specified as a position in the buffer.

3. The optional third argument, NOERROR, specifies how the function responds to
   failure: ‘nil’ as the third argument causes the function to signal an error
   (and print a message) when the search fails; any other value causes it to
   return ‘nil’ if the search fails and ‘t’ if the search succeeds.

4. The optional fourth, COUNT, is the repeat count.  A negative repeat count
   causes ‘re-search-forward’ to search backwards.

The template for ‘re-search-forward’ looks like this:

#+begin_src emacs-lisp
  (re-search-forward "REGULAR-EXPRESSION"
                     LIMIT-OF-SEARCH
                     WHAT-TO-DO-IF-SEARCH-FAILS
                     REPEAT-COUNT)
#+end_src

** ‘forward-sentence’
The command to move the cursor forward a sentence is usually bound to the key
command ‘M-e’.

*** Complete ‘forward-sentence’
Here is the code for ‘forward-sentence’, as of the time of writing of this book:

#+begin_src emacs-lisp
  (defun forward-sentence (&optional arg)
    "Move forward to next end of sentence.  With argument, repeat.
  With negative argument, move backward repeatedly to start of sentence.

  The variable `sentence-end' is a regular expression that matches
  ends of sentences.  Also, every paragraph boundary terminates
  sentences as well."
    (interactive "p")
    (or arg (setq arg 1))
    (let ((opoint (point))
          (sentence-end (sentence-end)))
      (while (< arg 0)
        (let ((pos (point))
              (par-beg (save-excursion (start-of-paragraph-text) (point))))
          (if (and (re-search-backward sentence-end par-beg t)
                   (or (< (match-end 0) pos)
                       (re-search-backward sentence-end par-beg t)))
              (goto-char (match-end 0))
            (goto-char par-beg)))
        (setq arg (1+ arg)))
      (while (> arg 0)
        (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
          (if (re-search-forward sentence-end par-end t)
              (skip-chars-backward " \t\n")
            (goto-char par-end)))
        (setq arg (1- arg)))
      (constrain-to-field nil opoint t)))
#+end_src

The function can take an optional numeric argument, ‘arg’.  Should it not
receive any argument, ‘arg’ will be bound to 1.

*** The ‘while’ loops
Nested within a ‘let’ statement are two ‘while’ loops.  The second ‘while’ loop
is fashioned as a decrementing loop, and its purpose is to move the point
forward.  Since the ‘while’ loop is set to repeat ‘arg’ times, it will move
point (‘goto-char’) to the ‘arg’th occurence of the ‘sentence-end’ regular
expression.

*** The Regular Expression Search
The ‘re-search-forward’ call looks for the ‘sentence-end’ regular expression,
bound by ‘par-end’.  Its third argument, ‘t’, specifies that, should a match not
be found, the function should not throw an error (it will then fail silently by
returning ‘nil’).  In the context of ‘forward-sentence’, this call is used for
its side effect, which is to move point to the end of the occurrence found.

If ‘re-search-forward’ found a match for its regular expression, it will return
a value of true, causing the then-part of its enclosing ‘if’ expression to
trigger: ‘(skip-chars-backward " \t\n")’.  This expression moves backwards over
any blank spaces, tabs or carriage returns until a printed character is found
and then leaves point after that character.  Since point has already been moved
to the end of the pattern that marks the end of the sentence, this action leaves
point right afte rthe closing printed character of the sentence, which is
usually a period.

Alternatively, should the ‘re-search-forward’ call fail, the function returns
‘nil’, causing the else-part of its enclosing ‘if’ statement to trigger:
‘(goto-char par-end)’.  This will move point to the end of the paragraph.

** ‘forward-paragraph’: a Goldmine of Functions
The ‘forward-paragraph’ function moves point forward to the end of the
paragraph.  It makes use of a number of relevant functions, including ‘let*’,
‘match-beginning’, and ‘looking-at’.

The ‘forward-paragraph’ function must account for fill prefixes.  A fill prefix
consists of a string of characters that are repeated at the beginning of each
line.  They are mode-specific conventions that carry a special meaning within a
paragraph, such like ‘;;; ’, which in Lisp mode are used to introduce a
paragraph comment; or four blank spaces, which in Text mode are used to create
an indented paragraph.

*** Shortened ‘forward-paragraph’ Function Definition
Outlined, the ‘forward-paragraph’ function looks like this:

#+begin_src emacs-lisp
  (defun forward-paragraph (&optional arg)
    "DOCUMENTATION..."
    (interactive "p")
    (or arg (setq arg 1))
    (let*
        (VARLIST)
      (while (and (< arg 0) (not (bobp))) ; backward-moving-code
        ...
        (while (and (> arg 0) (not (eobp)))) ; forward-moving-code
        ...
        )))
#+end_src

*** The ‘let*’ Expression
The ‘let*’ special form behaves like ‘let’, except that Emacs sets each variable
in sequence, with reference of the latter variables to the former ones.

In the ‘let*’ expression of ‘forward-paragraph’, Emacs binds a total of seven
variables: ‘opoint’, ‘fill-prefix-regexp’, ‘parstart’, ‘parsep’, ‘sp-parstart’,
‘start’, and ‘found-start’.

Noticeably, the variable ‘fill-prefix-regexp’ is set to the value returned by
evaluating the following list:

#+begin_src emacs-lisp
  (and fill-prefix
       (not (equal fill-pre ""))
       (not paragraph-ignore-fill-prefix)
       (regexp-quote fill-prefix))
#+end_src

The ‘and’ special form returns ‘nil’ should one of its arguments be ‘nil’;
otherwise it returns the value of its last argument.  The result of successfully
evaluating this ‘and’ expression is that ‘fill-prefix-regexp’ will be bound to
the value of fill-prefix as modified by the ‘regexp-quote’ function.  Otherwise,
the variable will be set to ‘nil’.

*** The Forward Motion ‘while’ Loop
The second part of the ‘let*’ deals with the forward motion.  It repeats itself
so long as the value of ‘arg’ is greater than zero.  The ‘while’ loop looks like
this:

#+begin_src emacs-lisp
  ;; going forwards and not at the end of the buffer
  (while (and (> arg 0) (not (eobp)))
    ;; between paragraphs
    ;; Move forward over separator lines...
    (while (and (not (eobp))
                (progn (move-to-left-margin) (not (eobp)))
                (looking-at parsep))
      (forward-line 1))
    ;; This decrements the loop
    (unless (eobp) (setq arg (1- arg)))
    ;; ... and one more line.
    (forward-line 1)

    (if fill-prefix-regexp
        ;; There is a fill prefix; it overrides parstart;
        ;; we go forward line by line
        (while (and (not (eobp))
                    (progn (move-to-left-margin) (not eobp))
                    (not (looking-at parsep))
                    (looking-at fill-prefix-regexp))
          (forward-line 1))

      ;; There is no fill prefix;
      ;; we go forward character by character
      (while (and (re-search-forward sp-parstart nil 1)
                  (not (looking-at parsep))
                  (looking-at fill-prefix-regexp))
        (forward-line 1))

      ;; There is no fill prefix; it overrides parstart;
      ;; we go forward line by line
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (not (looking-at parsep))
                  (looking-at fill-prefix-regexp))
        (forward-line 1))

      ;; There is no fill prefix;
      ;; we go forward character by character
      (while (and (re-search-forward sp-parstart nil 1)
                  (progn (setq start (match-beginning 0))
                         (goto-char start)
                         (not (eobp)))
                  (progn (move-to-left-margin)
                         (not (looking-at parsep)))
                  (or (not (looking-at parstart))
                      (and use-hard-newlines
                           (not (get-text-property (1- start) 'hard)))))
        (forward-char 1))

      ;; and if there is no fill prefix and if we are not at the end, go to
      ;; whatever was found in the regular expression search for sp-parstart
      (if (< (point) (point-max))
          (goto-char start))))
#+end_src

The function ‘looking-at’ returns ‘t’ if the text after point matches the
regular expression given as its argument.

The ‘match-beginning’ function returns the position of the text matched by the
last search.  Its argument (SUBEXP, a number), specifies which parenthesized
expression in the last regular expression to consider.  The returned value is
‘nil’ if the SUBEXPth pair didn’t match, or if there was less than SUBEXP pairs.
A value of zero for SUBEXP returns the position that is the start of the text
matched by the most recent search.

** Review
Here is a brief summary of some recently introduced functions in the last chapters.

*** ‘while’
Repeatedly evaluates the body of the expression so long as the first element of
the body tests true.  Then return ‘nil’.  The expression is evaluated for its
side effects.

*** ‘re-search-forward’
Searches for a pattern; if the pattern is found, move point to the position just
after it.  Takes four arguments, like ‘search-forward’:

1. A regular expression that specifies the pattern to search for.  This argument
   must be quoted in quotation marks.
   
2. Optionally, the limit of the search (given as a position in the bufffer).
   
3. Optionally, what to to if the search fails.  Either returns ‘nil’ or an error message.

4. Optionally, how many times to repeat the search; if negative, the search goes backwards.

*** ‘let*’
Bind some variables locally to particular values, and then evaluate the
remaining arguments, returning the value of the last one.  While binding the
local variables, use the local values of variables bound earlier, if any.

*** ‘match-beginning’
Returns the position of the start of the text found by the last regular
expression search.

*** ‘looking-at’
Returns ‘t’ (for true) if the text after point matches the argument, a regular
expression.

*** ‘eobp’
Returns ‘t’ (for true) if point is at the end of the accessible part of the
buffer (see [[Narrowing & Widening][Narrowing & Widening]]).

** Exercises
*** Exercise 12.1
Write a function to search for a regular expression that matches two or more
blank lines in sequence.

#+begin_src emacs-lisp
  (defun gtms-two-or-more-blanks ()
    "Searches for instances of two or more consecutive blank
  lines and leaves point after the last one."
    (interactive)
    (re-search-forward "\\(^\n\\)\\{2,\\}" nil t))
#+end_src

*** Exercise 12.2
Write a function to search for duplicated words, such as “the the”.  See [[info:Emacs#regexps][Syntax
of Regular Expressions]] (Emacs) for information on how to write a regular
expression to match a string that is composed of two identical halves.  See the
[[info:eintr#the-the][‘the-the’ Duplicated Words Function]] in the appendix for an example of how to
approach this problem.

#+begin_src emacs-lisp
  (defun gtms-the-the ()
    "Searches for the nearest instance of consecutive duplicated words and leaves point after the second one."
    (interactive)
    (re-search-forward "\\(\\<\\w+\\>\\)\\s-+\\1" nil t))
#+end_src

** Syntax of Regular Expressions
This section consists of notes taken from the section “[[info:emacs#regexps][Syntax of Regular
Expressions]]”, from the Emacs manual.

Regular expressions have a syntax in which a few characters are “special
constructs” and the rest are “ordinary”.  An ordinary character matches itself
and nothing else.

The special characters are ~$^.*+?[\~.  The character ~]~ is special if it ends
a character alternative.  The character ~-~ is special if inside a character
alternative.  Any other character appearing in a regular expression is ordinary,
unless a ~\~ precedes it.  (When you use regular expressions in a Lisp program,
each ~\~ must be doubled.)

Following is a list of special characters.

*** ‘.’ (Period)
A special character that matches /any/ single character except a newline.  For
example, the regular expression ~a.b~ matches any three-character string that
begins with ~a~ and ends with ~b~.

*** ‘*’
The asterisk is not a construct by itself; it is a postfix operator that means
to match the preceding regular expression repetitively any number of times, as
many times as possible.  Thus, ~o*~ matches any number of ~o~ ’s, including no
~o~ ’s.

~*~ always applies to the /smallest/ possible preceding expression.  Thus, ~fo*~
has a repeating ~o~, not a repeating ~fo~.  It matches ~f~, ~fo~, ~foo~, and so
on.

*** ‘+’
~+~ is a postfix operator, similar to ~*~, except that it must match the
preceding expression at least once.  Thus, ~ca+r~ matches the strings ~car~ and
~caaaar~ but not the string ~cr~, whereas ~ca*r~ matches all three strings.

*** ‘?’
~?~ is a postfix operator, similar to ~*~, except that it can match the
preceding expression either once or not at all.  Thus, ~ca?r~ matches ~car~ or
~cr~, and nothing else.

*** ‘*?’, ‘+?’ and ‘??’
These are the non-“greedy” variants of the operators above.  The regular
operators ~*~, ~+~ and ~?~ match as much as they can, as long as the overall
regexp can still match.  With a following ~?~, they will match as little as
possible.

Thus, both ~ab*~ and ~ab*?~ can match the string ~a~ and the string ~abbbb~; but
if you try to match them both against the text ~abbb~, ~ab*~ will match it all
(the longest valid match), while ~ab*?~ will match just ~a~ (the shortest valid match).

*** ‘\{N\}’
This postfix operator specifies N repetitions—that is, the preceding regular
expression must match exactly N times in a row.  For example, ~x\{4\}~ matches
the string ~xxxx~ and nothing else.

*** ‘\{N,M\}’
This postfix operator specifies between N and M repetitions—that is, the
preceding regular expression must match at least N times, but no more than M
times.  If M is omitted, then there is no upper limit, but the preceding regular
expression must match at least N times.

- ~\{0,1\}~ is equivalent to ~?~.
- ~\{0,\}~ is equivalent to ~*~.
- ~\{1,\}~ is equivalent to ~+~.

*** ‘[…]’
This construct defines a “character set”, beginning with ~[~ and terminated by
~]~.

In the simplest case, the characters between the two brackets are what this set
can match.  Thus, ~[ad]~ matches either one ~a~ or one ~d~, and ~[ad]*~ matches
any string composed of just ~a~ ’s and ~d~ ’s (including the empty string).  It
follows that ~c[ad]*r~ matches ~cr~, ~car~, ~cdr~, ~caddaar~, and so on.

You can also include character ranges in a character set, by writing the
starting and ending characters with a ~-~ between them.  Thus, ~[a-z]~ matches
any lower-case ASCII letter.  Ranges may be intermixed freely with individual
characters, as in ~[a-z$%.]~, which matches any lower-case ASCII letter /or/
~$~, ~%~ or period.

You can also include certain special “character classes” in a character set.  A
~[:~ and balancing ~:]~ enclose a character class inside a character
alternative.  For instance, ~[[:alnum:]]~ matches any letter or digit.  See the
“[[info:elisp#Char Classes][Character Classes]]” section of the elisp manual, for a list of character
classes.

To include a ~]~ in a character set, you must make it the first character.  For
example, ~[]a]~ matches ~]~ or ~a~.  To include a ~-~, write ~-~ as the first or
last character of the set, or put it after a range.  Thus, ~[]-]~ matches both
~]~ and ~-~.

To include ~^~ in a set, put it anywhere but at the beginning of the set.  (At
the beginning, it complements the set—see below.)

*** ‘[^…]’
The sequence ~[^~ begins a “complemented character set”, which matches any
character except the ones specified.  Thus, ~[^a-z0-9A-Z]~ matches all
characters /except/ ASCII letters and digits.  In a character set, ~^~ is not
special /unless/ it is the first character of the set.

*** ‘^’
The caret character, ‘^’, is a special character that matches the empty string,
but only at the beginning of a line in the text being matched.  Otherwise it
fails to match anything.  Thus, ~^foo~ matches a ~foo~ that occurs at the
beginning of a line.

*** ‘$’
The dollar sign character, ~$~, is similar to ~^~, but matches only at the end
of the line.  Thus, ~x+$~ matches a string of one ~x~ or more at the end of a
line.

*** ‘\’
The backslash character, ~\~, has two functions: it quotes the special
characters (including ~\~), and it introduces additional special constructs.

Because ~\~ quotes special characters, ~\$~ is a regular expression that matches
only ~$~, and ~\[~ is a regular expression that matches only ~[~, and so on.

* Counting Words
** The ‘count-words-example’ Function
Following are examples of function implementation to count words in Emacs.  They
seek to emulate the standard Emacs ‘count-words-region’:

#+begin_src emacs-lisp
 (defun count-words-region (start end &optional arg)
   "Count the number of words in the region.
 If called interactively, print a message reporting the number of
 lines, words, and characters in the region (whether or not the
 region is active); with prefix ARG, report for the entire buffer
 rather than the region.

 If called from Lisp, return the number of words between positions
 START and END."
   (interactive (if current-prefix-arg
                    (list nil nil current-prefix-arg)
                  (list (region-beginning) (region-end) nil)))
   (cond ((not (called-interactively-p 'any))
          (count-words start end))
         (arg
          (count-words--buffer-message))
         (t
          (count-words--message "Region" start end))))
#+end_src

*** Designing ‘count-words-example’
The function will consist of a ‘while’ loop that starts at the beginning of the
active region, then will use a regexp to move point from the boundary end of one
word to the next, keeping count of each jump.  The ‘while’ loop ends at the end
of the region, at which point a message with the count of words is returned to
the user.

Thus, the regexp must capture one or more word constituent characters followed,
optionally, by one or more characters that are /not/ word constituents.  The
regular expression for this is ~\w+\W*~.

The buffer’s syntax table determines which characters are deemed word
constituents and which are not.  Thus, the search expression for the function
should look like this:

#+begin_src emacs-lisp
  (re-search-forward "\\w+\\W*")
#+end_src

And here is a first draft of the function:

#+begin_src emacs-lisp
  ;; First version; has bugs!
  (defun count-words-example (beginning end)
    "Print number of words in the region.
    Words are defined as at least one word-constituent character followed by at least one character that is not a word-constituent.  The buffer's syntax table determines which characters these are."
    (interactive "r")
    (message "Counting words in region...")

  ;;; 1. Set up appropriate conditions.
    (save-excursion
      (goto-char beginning)
      (let ((count 0))

  ;;; 2. Run the while loop.
        (while (< (point) end)
          (re-search-forward "\\w+\\W*")
          (setq count (1+ count)))

  ;;; 3. Send a message to the user.
        (cond ((zerop count)
               (message
                "The region does NOT have any words."))
              ((= 1 count)
               (message
                "The region has one word."))
              (t
               (message
                "The region has %d words." count))))))
#+end_src

This version of the function does work, but not in all circumstances.

*** The Whitespace Bug in ‘count-words-example’
Two issues plague the current incantation of the function.  The first has to do
with the fact that if there is a word /beyond/ the region, it will still be
counted as point will only be verified to be greater than the end of the region
on the next ‘while’ check.  The second is related to what happens when there are
no words within the region: the function throws an error.

To fix these, we need to pass a bounding parameter to the ‘re-search-forward’
call, as well as an argument that instructs the function to return ‘nil’ when no
words are found:

#+begin_src emacs-lisp
  (re-search-forward "\\w+\\W*" end t)
#+end_src

However, by returning ‘nil’ when the region has no words, ‘re-search-forward’
will not move point and the next ‘while’ condition will still be true, causing
the loop to never end.  To avoid this, we encolse the ‘while’ condition within
an ‘and’ statement:

#+begin_src emacs-lisp
  (and (< (point) end) (re-search-forward "\\w+\\W*" end t))
#+end_src

With these changes, the final version of the function looks as follows:

#+begin_src emacs-lisp
    ;;; Final version: while
    (defun count-words-example (beginning end)
      "Print number of words in the region."
      (interactive "r")
      (message "Counting words in region ... ")

    ;;; 1. Set up appropriate conditions.
      (save-excursion
        (let ((count 0))
          (goto-char beginning)

    ;;; 2. Run the while loop.
          (while (and (< (point) end)
                      (re-search-forward "\\w+\\W*" end t))
            (setq count (1+ count)))

    ;;; 3. Send a message to the user.
          (cond ((zerop count)
                 (message
                  "The region does NOT have any words."))
                ((= 1 count)
                 (message
                  "The region has 1 word."))
                (t
                 (message
                  "The region has %d words." count))))))


#+end_src

** Count Words Recursively
We now consider how to write the same function using a ‘while’ loop with
recursion.  This will be achieved with two functions: one, the recursive
function, performs the count; the other, the wrapper or main function, will be
invoked by the user, make a call to the recursive function, and return a
formatted message with the word count in the region.

The main body of this iteration of ‘count-words-example’ is similar to the first
version and binds the result of the call to the recursive function within the
context of a ‘let’ statement:

#+begin_src emacs-lisp
  (defun count-words-example (beginning end)
    "Print number of words in the region.

      Words are defined as at least one word-consituent character
      followed by at least one character that is not a
      word-constituent.  The buffer's syntax table determines which
      characters these are."
    (interactive "r")

  ;;; 1. Set up appropriate conditions.
    (message "Counting words in region ... ")
    (save-excursion
      (goto-char beginning)

  ;;; 2. Count the words.
      (let ((count (recursive-count-words end)))

  ;;; 3. Send a message to the user.
        (cond ((zerop count)
               (message
                "The region does NOT have any words."))
              ((= 1 count)
               (message
                "The region has 1 word."))
              (t
               (message
                "The region has %d words." count))))))
#+end_src

A recursive function has at least three parts: the do-again-test, the
next-step-expresssion, and the recursive call.

In this vein, the ‘recursive-count-words’ will look like this:

#+begin_src emacs-lisp
    (defun recursive-count-words (region-end)
      "Number of words between point and REGION-END."

    ;;; 1. do-again-test
      (if (and (< (point) region-end)
               (re-search-forward "\\w+\\W*" region-end t))

    ;;; 2. then-part: the recursive call
          (1+ (recursive-count-words region-end))

    ;;; 3. else-part
        0))
#+end_src

** Exercise
Using a ‘while’ loop, write a function to count the number of punctiation marks
in a region—period, comma, semicolon, colon, exclamation mark, and question
mark.  Do the same using recursion.  Do the same with recursion.

*** With ‘while’ Loop

#+begin_src emacs-lisp
  (defun gtms-count-punctuation (beginning end)
    "Counts the number of punctuation marks in the region.

  (Period, comma, semicolon, colon, exclamation mark and question
  mark are punctiation marks."
    (interactive "r")
    (save-excursion
      (let ((count 0))
        (goto-char beginning)
        (while (and (< (point) end)
                    (re-search-forward "\\s." end t)) ; Note that this
                                                            ; regular expression
                                                            ; could be replaced
                                                            ; by "[[:punct:]]";
                                                            ; this would however
                                                            ; match parentheses
                                                            ; as well.
          (setq count (1+ count)))
        (cond ((zerop count)
               (message
                "The region does not have any punctuation marks!"))
              ((= 1 count)
               (message
                "The region has one punctuation mark."))
              (t
               (message
                "The region has %d punctuation marks." count))))))
#+end_src

*** With Recursion

#+begin_src emacs-lisp
  (defun gtms-count-punctuation-recursive-wrapper (beginning end)
    "Counts the number of punctuation marks in the region.

  (Period, comma, semicolon, colon, exclamation mark and question
  mark are punctiation marks."
    (interactive "r")
    (save-excursion
      (goto-char beginning)
      (let ((count (gtms-count-punctuation-recursive end)))
        (cond ((zerop count)
               (message
                "The region does not have any punctuation marks!"))
              ((= 1 count)
               (message
                "The region has one punctuation mark."))
              (t
               (message
                "The region has %d punctuation marks." count))))))

  (defun gtms-count-punctuation-recursive (region-end)
      "Number of punctuation marks between point and REGION-END."
      (if (and (< (point) region-end)
               (re-search-forward "\\s." region-end t))
          (1+ (gtms-count-punctuation-recursive region-end))
        0))
#+end_src

* Words in a defun
The next chapters will generalise the use of our function to count words to
count (and plot) the number of symbols within Emacs functions.

** Divide and Conquer
The task at hand will be divided in five steps:

1. Write a function to count the words in one function definition.  This
   includes the problem of handling symbols as well as words.

2. Write a function to list the number of words in eahc function in a file.
   This function can use ‘count-words-in-defun’ function.

3. Write a function to list the number of words in each function in each of
   several files.  This entails automatically finding the various files,
   switching to them, and counting the words in the definitions within them.

4. Write a function to convert the list of numbers that created in step three to
   form what will be suitable in a graph.

5. Write a function to print the results in a graph.

** What to Count?
The regexp we used in ‘count-words-example’, ~"\\w+\\W*"~, is not suitable to
capture symbols in a function definition.  This leads us to consider the Emacs
Lisp syntax, in particular what constitutes a word or a symbol in the language.

** What Constitutes a Word or Symbol?
To have the regexp of ‘count-words-example’ correctly match defun symbols, we
need to modify it to match word constituent characters interspersed with symbol
characters, such as the hyphen.  In addition, we need to modify the second part
to optionally match characters that are not white-space, optionally followed by
non-white-space characters.  This yields the following regular expression:

#+begin_src emacs-lisp
"\\(\\w+\\|\\s_\\)+\\S-*\\s-*"
#+end_src

** The ‘count-words-in-defun’ Function
Here is the interactive version of the ‘count-words-defun’:

#+begin_src emacs-lisp
  ;;; Interactive version.
  (defun count-words-in-defun ()
    "Return the number of words and symbols in a defun."
    (beginning-of-defun)
    (let ((count 0)
          (end (save-excursion (end-of-defun) (point))))
      (while
          (and (< (point) end)
               (re-search-forward
                "\\(\\w\\|\\s_\\)+\\S-*\\s-*"
                end t))
        (setq count (1+ count)))
      count))

  (defun count-words-defun ()
    "Number of words and symbols in a function definition."
    (interactive)
    (message
     "Counting words and symbols in funtion definition ... ")
    (let ((count (count-words-in-defun)))
      (cond
       ((zerop count)
        (message
         "The definition does NOT have any words or symbols."))
       ((= 1 count)
        (message
         "The definition has one word or symbol."))
       (t
        (message
         "The definition has %d words or symbols." count)))))
#+end_src

We now need to extend the function’s functionality to count the numbers of words
and symbols in several definitions within a single file.

** Count Several ‘defuns’ Within a File
For each file, we will collect the number of words or symbols for each function
definition in a list like so:

#+begin_src emacs-lisp
  (goto-char (point-min))
  (while (re-search-forward "^(defun" nil t)
    setq lenghts-list
    (cons (count-words-in-defun) lengths-list))
#+end_src

** Find a File
To direct Emacs’s attention to the file containing the function definitions we
aim to analyse, we do not need to change the actively set buffer (something that
would be done if we resorted to the interactive functions ‘find-file’ and
‘switch-to-buffer’).  Instead, we will use the functions ‘find-file-noselect’
and ‘set-buffer’.

** ‘length-list-file’ in Detail
Here’s the function tasked with finding a file, ensuring that the point is
located at the beginning of the file, moving point forward defun by defun, and
retrieving the count of words and symbols in each defun:

#+begin_src emacs-lisp
  (defun lengths-list-file (filename)
    "Return list of definitions' lengths within file FILENAME.
  The returned list is a list of numbers.  Each number is the
  number of words or symbols in one function definition."
    (message "Working on `%s' ... " filename)
    (save-excursion
      (let ((buffer (find-file-noselect filename))
            (lengths-list))
        (set-buffer buffer)
        (setq buffer-read-only t)
        (widen)
        (goto-char (point-min))
        (while (re-search-forward "^(defun" nil t)
          (setq lengths-list
                (cons (count-words-in-defun) lengths-list)))
        (kill-buffer buffer)
        lengths-list)))
#+end_src

Here we run the function to count the number of words and symbols in each of the
defuns included in the file debug.el.gz from the 26.3 GNU Emacs distribution:

#+begin_src emacs-lisp
  (lengths-list-file
   "/usr/share/emacs/26.3/lisp/emacs-lisp/debug.el.gz")
#+end_src

#+RESULTS:
| 76 | 26 | 135 | 33 | 112 | 78 | 24 | 155 | 33 | 94 | 44 | 18 | 38 | 41 | 41 | 18 | 72 | 24 | 38 | 38 | 110 | 26 | 29 | 100 | 49 | 42 | 304 | 149 | 476 |

** Count Words in ‘defuns’ in Different Files
We now aim to loop the call of ‘lengths-list-file’ across multiple files.
Another ‘while’ loop or recursion will be needed for this.

*** Determine the Lengths of ‘defuns’

#+begin_src emacs-lisp
  ;;; Use `while' loop.
  (defun length-list-many-files (list-of-files)
    "Return list of lengths of defuns in LIST-OF-FILES."
    (let (lengths-list)

  ;;; true-or-false-test
      (while list-of-files
        (setq lengths-list
              (append
               lengths-list

  ;;; Generate a lengths' list.
               (lengths-list-file
                (expand-file-name (car list-of-files)))))

  ;;; Make file' list shorter.
        (setq list-of-files (cdr list-of-files)))

  ;;; Return final value of lengths' list.
      lengths-list))
#+end_src

The ‘expand-file-name’ function converts its filename argument NAME to an
absolute path, and canonicalises it.  To achieve this, the function employes the
name of the directory in which the function is called.

*** The ‘append’ Function
The ‘append’ function attaches one list to another.  Thus,

#+begin_src emacs-lisp
  (append '(1 2 3 4) '(5 6 7 8))
#+end_src

produces the list

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |

Notice the contrast with ‘cons’,

#+begin_src emacs-lisp
  (cons '(1 2 3 4) '(5 6 7 8))
#+end_src

which produces the list

#+RESULTS:
| (1 2 3 4) | 5 | 6 | 7 | 8 |

** Recursively Count Words in Different Files
Following is the recursive version of ‘lengths-list-many-files’:

#+begin_src emacs-lisp
  (defun recursive-lengths-list-many-files (list-of-files)
    "Return list of lengths of each defun on LIST-OF-FILES."
    (if list-of-files
        (append
         (lengths-list-file
          (expand-file-name (car list-of-files)))
         (recursive-lengths-list-many-files
          (cdr list-of-files)))))
#+end_src

To test the function, we can evaluate the following code:

#+begin_src emacs-lisp
  (cd "/usr/share/emacs/26.3/")

  (recursive-lengths-list-many-files
   '("./lisp/macros.el.gz"
     "./lisp/mail/mailalias.el.gz"
     "./lisp/makesum.el.gz"))
#+end_src

#+RESULTS:
| 263 | 248 | 387 | 87 | 38 | 35 | 32 | 87 | 175 | 84 | 69 | 90 | 421 | 212 | 336 | 82 | 181 |

** Prepare the Data for Display in a Graph
The next task consists of preprocessing (binning and counting occurrences per
ranged bin) the data list for plotting.

*** Data for Display in Detail
We will start by sorting the lengths' list first.

*** Sorting Lists
The ‘sort’ function takes two arguments, (1) the list to be sorted and (2) a
predicate that determines whether the first of two list elements is less than
the second.

Typically, the ‘<’ function is used when sorting a numeric list.  For example,

#+begin_src emacs-lisp
  (sort '(4 8 21 17 33 7 21 7) '<)
#+end_src

Produces the following:

#+RESULTS:
| 4 | 7 | 7 | 8 | 17 | 21 | 21 | 33 |

(Note that, in this example, both arguments are quoted so that the symbols are
not evaluated before being passed to ‘sort’ as arguments.)

Sorting the list returned by the ‘recursive-lengths-list-many-files’ function is
straightforward; it uses the ‘<’ function:

#+begin_src emacs-lisp
  (cd "/usr/share/emacs/26.3/")

  (sort
   (recursive-lengths-list-many-files
    '("./lisp/macros.el.gz"
      "./lisp/mail/mailalias.el.gz"
      "./lisp/makesum.el.gz"))
   '<)
#+end_src

#+RESULTS:
| 32 | 35 | 38 | 69 | 82 | 84 | 87 | 87 | 90 | 175 | 181 | 212 | 248 | 263 | 336 | 387 | 421 |

*** Making a List of Files
We now need a function to extract all the source files living within a
directory.  We thus aim to create a function that will enable us to feed
filenames to ‘recursive-lengths-list-many-files’ as a list that looks like this:

#+begin_src emacs-lisp
  ("./lisp/macros.el.gz"
   "./lisp/mail/rmail.el.gz"
   "./lisp/makesum.el.gz")
#+end_src

This ‘files-in-below-directory’ function must accomplish the following:

  + Check to see whether it is looking at a filename that ends in ~.el.gz~; and
    if so, add its name to a list.

  + Check to see whether it is looking at a filename that is the name of a
    directory; and if so,
    
    - Check to see whether it is looking at ~.~ or ~..~; and if so, skip it.
      
    - Or else, move into that directory and repeat the process.

Here is the function:

#+begin_src emacs-lisp
  (defun files-in-below-directory (directory)
    "List the `.el.gz' files in DIRECTORY and its sub-directories."
    ;; Although the function will be used non-interactively, it will be easier to
    ;; test if we make it interactive.  The directory will have a name such as
    ;; "/usr/local/share/emacs/26.3/lisp".
    (interactive "DDirectory name: ")
    (let (el-files-list
          (current-directory-list
           (directory-files-and-attributes directory t)))
      ;; while we are in the current directory
      (while current-directory-list
        (cond
         ;; check to see whether filename ends in `el.gz' and, if so, add its name
         ;; to a list.
         ((equal ".el.gz" (substring (car (car current-directory-list)) -6))
          (setq el-files-list
                (cons (car (car current-directory-list)) el-files-list)))
         ;; check whether filename is that of a directory
         ((eq t (car (cdr (car current-directory-list))))
          ;; decide whether to skip or recurse
          (if
              (equal "."
                     (substring (car (car current-directory-list)) -1))
              ;; then do nothing since filename is that of current or parent
              ;; directory, "." or ".."
              nil
            ;; else descend into the directory and repeat the process
            (setq el-files-list
                  (append
                   (files-in-below-directory
                    (car (car current-directory-list)))
                   el-files-list)))))
        ;; move to the next filename in the list; this also shortens the list so
        ;; the while loop eventually comes to an end
        (setq current-directory-list (cdr current-directory-list)))
      ;; return the filenames
      el-files-list))
#+end_src

We can test the function by feeding it the base directory of all ~.el.gz~ source
files in Emacs’s system installation:

#+begin_src emacs-lisp
  (length
   (files-in-below-directory "/usr/share/emacs/26.3/lisp"))
#+end_src

#+RESULTS:
: 1461

*** Counting Function Definitions 
The bins are defined by the list ‘top-of-ranges’ as follows:

#+begin_src emacs-lisp
     (defvar top-of-ranges
      '(10  20  30  40  50
        60  70  80  90 100
       110 120 130 140 150
       160 170 180 190 200
       210 220 230 240 250
       260 270 280 290 300)
      "List specifying ranges for `defuns-per-range'.")
#+end_src

To parse the number of length observations in each bin, we will deploy the
‘defuns-per-range’ function:

#+begin_src emacs-lisp
  (defun defuns-per-range (sorted-lengths top-of-ranges)
    "SORTED-LENGTHS defuns in each TOP-OF-RANGES ranges."
    (let ((top-of-range (car top-of-ranges))
          (number-within-range 0)
          defuns-per-range-list)

      ;; Outer loop
      (while top-of-ranges

        ;; Inner loop
        (while (and
                ;; Need number for numeric test
                (car sorted-lengths)
                (< (car sorted-lengths) top-of-range))

          ;; Count number of definitions within current range
          (setq number-within-range (1+ number-within-range))
          (setq sorted-lengths (cdr sorted-lengths)))

        ;; Exit inner loop but remain within outer loop

        (setq defuns-per-range-list
              (cons number-within-range defuns-per-range-list))
        (setq number-within-range 0)      ; Reset count to zero

        ;; Move to next range
        (setq top-of-ranges (cdr top-of-ranges))
        ;; Specify next top of range value
        (setq top-of-range (car top-of-ranges)))

      ;; Exit outer loop and count the number of defuns larger the largest
      ;; `top-of-range' value
      (setq defuns-per-range-list
            (cons
             (length sorted-lengths)
             defuns-per-range-list))

      ;; Return a list of the number of definitions within each range, smallest to
      ;; largest
      (nreverse defuns-per-range-list)))
#+end_src

We can test the function by evaluating the following code:

#+begin_src emacs-lisp
  ;; (Shorter list than we will use later.)
  (setq top-of-ranges
        '(110 120 130 140 150
              160 170 180 190 200))

  (setq sorted-lengths
        '(85 86 110 116 122 129 154 176 179 200 265 300 300))

  (defuns-per-range sorted-lengths top-of-ranges)
#+end_src

#+RESULTS:
| 2 | 2 | 2 | 0 | 0 | 1 | 0 | 2 | 0 | 0 | 4 |
* Readying a Graph
* Emacs Initialization
* Debugging
* Conclusion
* the-the
* Kill Ring
* Full Graph
* Free Software and Free Manuals
* GNU Free Documentation License

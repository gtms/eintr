#+STARTUP: content

* List Processing
Lisp stands for “Lots of Isolated Silly Parentheses”.  Or, more prosaically,
“LISt Processing”.  Lists are contained within parentheses.  Lists are the basis
of Lisp.

** Lisp Lists
This is a Lisp list:
#+begin_src emacs-lisp
  '(rose
    violet
    daisy
    buttercup)
#+end_src

#+RESULTS:
| rose | violet | daisy | buttercup |

*** Numbers, List inside Lists
Here is another list, this time with a list inside of it:
#+begin_src emacs-lisp
  '(this list has (a list inside of it))
#+end_src

#+RESULTS:
| this | list | has | (a list inside of it) |

*** Lisp Atoms
The empty list, ‘()’, is considered both an atom and a list at the same time.
“Symbolic expressions” or, more concisely, “s-expressions”, are the printed
representation of both atoms and lists.  Also, the word “form” can be used as a
synonym for expression.

Atoms are indivisible semantic units.  Numbers and symbols are examples of
atoms.  Text betwen double quotation marks (even sentences or paragraphs) is
also an atom.  Here is an example:
#+begin_src emacs-lisp
  '(this list includes "text between quotation marks.")
#+end_src

#+RESULTS:
| this | list | includes | text between quotation marks. |

This kind of atom is called a “string” (for “string of characters”).

*** Whitespace in Lists
The amount of whitespace in a list does not matter.

In brief, a list is between parentheses, a string is between quotation marks, a
symbol looks like a word, and a number looks like a number.

** Run a Program
The Lisp interpreter will evaluate a list unless it is preceded by a quote
(‘'’).  If quoted, the list is returned as is:

#+begin_src emacs-lisp
  '(this is a quoted list)
#+end_src

#+RESULTS:
| this | is | a | quoted | list |

If unquoted, the interpreter will take the first item of the list as a function
to execute, with the remaining elements of the list taken as arguments:

#+begin_src emacs-lisp
  (+ 2 2)
#+end_src

#+RESULTS:
: 4

** Making Errors
Alternatively, if the list is not compliant with the language syntax, an error
message is returned by the GNU Emacs debugger:

#+begin_src emacs-lisp
  (this is an unquoted list)
#+end_src

This instruction will invoke the debugger, which is opened in a buffer named
*Backtrace*.  To quit the debugger, type ‘q’.  The *Backtrace* shows the series
of steps that the interpreter took to evaluate the given s-expression, from the
bottom up.  The last of these messages, at the top of the *Backtrace* buffer,
conveys the absence of an instruction registered with the symbol ‘this’; in
other words, there is no function that can be executed by this list.  Thus,
‘this’ is a ‘void-function’.

** Names & Definitions
A function may have different symbols associated to it (e.g., ‘+’ anld ‘plus’ both
can refer to the set of instructions used to add numbers).  Conversely, a symbol
can have only one function associated to it at a time.

As Emacs only has one namespace, it is customary to name symbols in a way that
identifies the function with the feature of Emacs it is associated with.  Thus,
all the names for functions related to Texinfo start with ‘texinfo-’ and those
for functions that deal with reading mail start with ‘rmail-’.

** Lisp Interpreter
The Lisp interpreter first looks to see whether there is a quote before the
list; if there is, the interpreter just returns a list.  If there is no quote,
the interpreter looks at the first element olf the list and sees whether it has a
function definition.  If it does, the interpreter carries the instructions in
the function definition.  Otherwise, the interpreter prints an error message.

*** Complications
In addition to these case scenarios, the Lisp interpreter can evaluate a symbol
that is not quoted and does not have parentheses around it.  In this case, the
interpreter will attempt to determine the symbol’s value as a “variable”.

There is also an exception for unusual functions called “special forms”.  They
are used for special tasks, like defining a function, and there are not many of
them.

As well as special forms, there are also “macros”.  A macro is a construct
defined in Lisp, which differs from a function in that it translates a Lisp
expression into another expression that is to be evaluated in place of the
original expression.

The Lisp interpreter evaluates nested lists from the inside out, i.e., first it
evaluates the innermost list (the result of which can be used in the evaluation
of the enclosing expression), up to the outermost list.

*** Bite Compiling
The Lisp interpreter is able to interpret human readable code as well as byte
compiled code.  Bite compiled code is usually stored in a file with an ‘.elc’
extension, as opposed to a ‘.el’ extension, reserved for human readable code.

** Evaluation
“To ascertain the value or amount of; to appraise”, according to ‘Webster’s New
Collegiate Dictionary’.

*** How the Interpreter Acts
Evaluating a symbolic expression most commonly causes the Lisp interpreter to
return a value and perhaps carry out a side effect; or else produce an error.

*** Evaluating Inner Lists
In nested lists, the innermost list is evaluated first and its returning value
is passed to the enclosing list.  The outer expressions are then successively
evaluated (if any), up to the outermost list:

#+begin_src emacs-lisp
  (+ 2 (+ 3 3))
#+end_src

#+RESULTS:
: 8

** Variables
In Emacs Lisp, a symbol can have a value attached to it just as it can have a
function definition attached to it.  The value of a symbol can be any expression
in Lisp, such as a symbol, number, list of string.  A symbol that has a value is
often called a “variable”.  A symbol can have both a function definition and a
value attached to it at the same time.

*** fill-column example
In order to find the value attached to a variable, one needs to evaluate its
symbol:

#+begin_src emacs-lisp
fill-column
#+end_src

#+RESULTS:
: 80

*** Void Function
Note that, in the previous example, the symbol ‘fill-column’ was evaluated by
itself, and not within the context of a list.  This is because if it were
evaluated within a list, the Lisp interpreter would attempt to find the function
definition attached to it, when ‘fill-column’ has no function definition:

#+begin_src emacs-lisp
(fill-column)
#+end_src

This expression will generate a *Backtrace* buffer stating that the symbol
‘fill-column’ is a “void function”.

*** Void Variable
In addition, evaluating a symbol that does not have a value bound to it also
generates an error message.  For instance, in the following expression:

#+begin_src emacs-lisp
(+ 2 2)
#+end_src

running the command ‘eval-last-sexp’ (‘C-x C-e’), with the cursor right after
the ‘+’, will generate a *Backtrace* buffer stating that the symbol ‘+’ is a
“void variable”.  This is because the interpreter sought to look for the value
of a variable, by virtue of the fact that the “last expression” evaluated was
the symbol ‘+’, and not a list in which the first element would then be
interpreted as a function definition.

** Arguments
In Lisp, the arguments to a function are the atoms or lists that follow the
function.  The values returned by the evaluation of these atoms or lists are
passed to the function.  Different functions require different numbers of
arguments; some functions require none at all.

*** Data types
The type of data that should be passed to a function depends on what kind of
information it uses.  For example, the ‘concat’ function links together two or
more strings of text to produce a string.  The arguments are strings:

#+begin_src emacs-lisp
  (concat "abc" "def")
#+end_src

#+RESULTS:
: abcdef

The function ‘substring’ takes two types of arguments, a string and up to two
numbers that delimit the substring to return:

#+begin_src emacs-lisp
  (substring "The quick brown fox jumped." 16 19)
#+end_src

#+RESULTS:
: fox

Note that the string passed to ‘substring’ is a single atom even though it is
made up of several words separated by spaces.

*** An Argument as the Value of a Variable or List
An argument can be a symbol that returns a value when it is evaluated.  For
example, when the symbol ‘fill-column’ by itself is evaluated, it returns a
number.  This number can be used in an addition:

#+begin_src emacs-lisp
  (+ 2 fill-column)
#+end_src

#+RESULTS:
: 82

In addition, an argument can be a list that returns a value when it is
evaluated:

#+begin_src emacs-lisp
  (concat "The " (number-to-string (+ 2 fill-column)) " red foxes.")
#+end_src

#+RESULTS:
: The 82 red foxes.

*** Variable Number of Arguments
Some functions, such as ‘concat’, ‘+’ or ‘*’, take any number of arguments:

#+begin_src emacs-lisp
  (+) ; 0
  (*) ; 1
  (+ 3) ; 3
  (* 3) ; 3
  (+ 3 4 5) ; 12
  (* 3 4 5) ; 60
#+end_src

*** Wrong Type of Argument
When a function is passed  an argument of the wrong type, the Lisp interpreter
produces an error message.  For instance, the following example:

#+begin_src emacs-lisp
  (+ 2 'hello)
#+end_src

will produce a *Backtrace* buffer stating that the argument is of the wrong
type.  More specifically, the debugger message implies that the symbol passed as
argument (the quoted symbol ‘hello’) failed the “number or marker” test (a
marker is a special object representing a buffer position).

The ‘p’ of ‘number-or-marker-p’ stands for “predicate”.  A predicate is a
function to determine if some property is true or false.  Other Lisp symbols
that end in ‘p’ include ‘zerop’, a function that tests whether its argument has
the value of zero, and ‘listp’, a function that tests whether its argument is a
list.

*** The ‘message’ function
The ‘message’ function takes a variable number of arguments and is used to post
messages in the echo aread to the user:

#+begin_src emacs-lisp
  (message "This message appears in the echo area!")
#+end_src

#+RESULTS:
: This message appears in the echo area!

The format control strings ‘%s’ and ‘%d’ in the quoted string of characters are
replaced in the returned message respectively by string and integer arguments,
in the order that they appear in the argument list passed to the function:

#+begin_src emacs-lisp
  (message "The name of this buffer is: %s." (buffer-name))
#+end_src

#+RESULTS:
: The name of this buffer is: eintr.org.

#+begin_src emacs-lisp
  (message "The value of fill-column is: %d." fill-column)
#+end_src

#+RESULTS:
: The value of fill-column is: 80.

Here are two more complex examples:

#+begin_src emacs-lisp
  (message "There are %d %s in the office!"
           (- fill-column 14) "pink elephants")
#+end_src

#+RESULTS:
: There are 66 pink elephants in the office!

#+begin_src emacs-lisp
  (message "He saw %d %s"
           (- fill-column 32)
           (concat "red "
                   (substring
                    "The quick brown foxes jumped." 16 21)
                   " leaping."))
#+end_src

#+RESULTS:
: He saw 48 red foxes leaping.

** set & setq
One way by which to “bind” a variable to a value is to use either the function
‘set’ or the function ‘setq’.  Another way is to use the special form ‘let’.

*** Using set
When evaluated, the following expression will set the value of the symbol
‘flowers’ to the list ‘'(rose violet daisy buttercup)’:

#+begin_src emacs-lisp
  (set 'flowers '(rose violet daisy buttercup))
#+end_src

#+RESULTS:
| rose | violet | daisy | buttercup |

This happens as a side effect of returning the list itself.  Once set,
evaluating the symbol flowers will return the list it was assigned:

#+begin_src emacs-lisp
  flowers
#+end_src

#+RESULTS:
| rose | violet | daisy | buttercup |

However, evaluating the quoted symbol ‘'flowers’ will return the symbol itself:

#+begin_src emacs-lisp
  'flowers
#+end_src

#+RESULTS:
: flowers

*** Using setq
The special form ‘setq’ behaves like ‘set’ except that the first argument is
quoted automatically:

#+begin_src emacs-lisp
  (setq carnivores '(lion tiger leopard))
#+end_src

#+RESULTS:
| lion | tiger | leopard |

In addition, setq allows for the binding of several symbol/value pairs within
the same expression, by having each even argument bound to the preceding odd
symbol:

#+begin_src emacs-lisp
  (setq trees '(pine fir oak maple)
        herbivores '(gazelle antelope zebra))
#+end_src

#+RESULTS:
| gazelle | antelope | zebra |

*** Counting
Here is an example that shows how to use ‘setq’ in a counter:

#+begin_src emacs-lisp
  (setq counter 0)                      ; The initializer
  (setq counter (+ counter 1))          ; The incrementer
  counter                               ; The counter
#+end_src

** Summary
+ Lisp programs are made up of expressions, which are lists or single atoms.

+ Lists are made up of zero or more atoms or inner lists, separated by
  whitespace and surrounded by parentheses.  A list can be empty.

+ Atoms are multi-character symbols, like ‘forward-paragraph’, single character
  symbols like ‘+’, strings of characters between double quotation marks, or
  numbers.

+ A number evaluates to itself.

+ A string between double quotes evaluates to itself.

+ A symbol evaluated by itself returns its value.

+ When a list is evaluated, the Lisp interpreter looks at the first symbol in
  the list and then at the function definition bound to that symbol.  Then the
  instructions in the function definition are carried out.

+ The single quote ‘'’ tells the Lisp interpreter that it should return the
  following expression as written, and not evaluate it as it would if the quote
  were not there.

+ Arguments are the information passed to a function.  The arguments to a
  function are computed by evaluating the rest of the elements of the list of
  which the function is the first element.

+ A function always retuns a value when it is evaluated (unless it gets an
  error); in addition, it may also carry out some action that is a side effect.
  In many cases, a function’s primary purpose is to create a side effect.

** Exercises
*** Exercise 1.1
Generate an error message by evaluating an appropriate symbol that is not
within parentheses.

#+begin_src emacs-lisp
symbol
#+end_src

*** Exercise 1.2
Generate an error message by evaluating an appropriate symbol that is between
parentheses.

#+begin_src emacs-lisp
  (fill-column)
#+end_src

*** Exercise 1.3
Create a counter that increments by two rather than one.

#+begin_src emacs-lisp
  (setq counter2 0)
  (setq counter2 (+ counter2 2))
  counter2
#+end_src

*** Exercise 1.4
Write an expression that prints a message in the echo area when evaluated.

#+begin_src emacs-lisp
  (message "Exercises from chapter one are completed!")
#+end_src

* Practicing Evaluation
Symbol and lists can be evaluated.  When evaluating a list, the Lisp interpreter
looks for a function definition for its first element.  The instructions of the
function definition are then carried out with the arguments provided by the
subsequent elements of the list.

** How to Evaluate
In Emacs, editing commands are executed via the evaluation of an expression, the
first element of which is a function.  For instance, typing plain text is
achieved through the evaluation of an Emacs Lisp function,
‘self-insert-command’.  Such functions are called “interactive” functions, or
“commands”.

Another way to evaluate an expression is by running the command
‘eval-last-sexp’, which can be done by positioning the cursor after a list and
typing ‘C-x C-e’.

** Buffer Names
The difference between file and buffer is illustrated by the functions
‘buffer-name’ and ‘buffer-file-name’.  While evaluating the expression
‘(buffer-name)’ returns the name of the current buffer, evaluating
‘(buffer-file-name)’ retrieves the full path-name of the file:

#+begin_src emacs-lisp
  (buffer-name) ; "eintr.org[emacs-lisp]"

  (buffer-file-name) ; "/home/gtomas/Documents/programming/emacs-lisp/org/eintr/eintr.org"
#+end_src

** Getting Buffers
The ‘buffer-name’ function returns the /name/ of the buffer; to get the buffer
/itself/, the ‘current-buffer’ function is used.  Upon evaluation of this
function, the current buffer is returned as a lisp object; this is done as a
side effect of returning a specially formatted form of the buffer’s name:

#+begin_src emacs-lisp
  (current-buffer) ; #<buffer eintr.org[emacs-lisp]>
#+end_src

A related function is ‘other-buffer’.  This returns the most recently selected
buffer (that is not visible in another window) other than the one currently in
focus:

#+begin_src emacs-lisp
  (other-buffer) ; #<buffer *eshell*>
#+end_src

** Switching Buffers
The ‘other-buffer’ function provides a buffer when it is used as an argument to
a function that requires one.  It can thus be fed to the function
‘switch-to-buffer’:

#+begin_src emacs-lisp
  (switch-to-buffer (other-buffer))
#+end_src

This will skip any buffer currently displayed.  To move to the most recent
buffer, regardless of whether the buffer is already displayed in frame, the
following expression needs to be evaluated:

#+begin_src emacs-lisp
  (switch-to-buffer (other-buffer (current-buffer) t))
#+end_src

‘set-buffer’ achieves a similar goal to ‘switch-to-buffer’, with one difference:
it does not display the buffer itself (it us thus best suited for programmatic
purposes instead).

** Buffer Size & Locations
The function ‘buffer-size’ returns the size of the current buffer (a count of
the number of characters in the buffer):

#+begin_src emacs-lisp
  (buffer-size) ; 32086
#+end_src

In Emacs, the current position of the cursor is called “point”.  The expression
‘(point)’ returns an integer corresponding to the number of characters from the
beginning of the buffer to point:

#+begin_src emacs-lisp
  (point) ; 17635
#+end_src

The function ‘point-min’ returns the value of the minimum value of point in the
current buffer (which should be one unless “narrowing” is in effect).  Likewise,
the function ‘point-max’ returns the value of the maximum permissible value of
point in the current buffer.

** Exercise
Find a file with which you are working and move towards its middle.  Find its
buffer name, file name, length, and your position in the file.

#+begin_src emacs-lisp
  (switch-to-buffer (current-buffer)) ; switch to this file
  (goto-char (/ (buffer-size) 2))     ; move to its middle
  (buffer-name) ; return the name of the buffer
  (buffer-size) ; return the size (number of characters) of the buffer
  (point)       ; return the position of the point in the file
#+end_src

* How to Write Function Definitions
A symbol that has a function definition is called a function (technically, the
definition is the function and symbol /refers/ to it).

** Primitive Functions
All functions are defined in terms of other functions, except for “primitive”
functions that are written in the C programming language.  Function definitions
are written in Emacs Lisp and use other functions a their building blocks.

** defun
A function definition has up to five parts following the symbol ‘defun’:

1. The name of the symbol to which the function definition is attached.

2. A list of the arguments that will be passed to the function.  If no arguments
   will be passed to the function, this is the empty list, ‘()’.

3. Documentation describing the function.  Although technically optional, this
   is strongly recommended.

4. Optionally, an expression to make the function interactive so that it can be
   used by typing ‘M-x’ and then the name of the function; or by typing an
   appropriate key or keychord.

5. The code that instructs the computer what to do: the “body” of the function
   definition.

The template of a function definition looks like this:

#+begin_src emacs-lisp
  (defun FUNCTION-NAME (ARGUMENTS...)
    "OPTIONAL-DOCUMENTATION..."
    (interactive ARGUMENT-PASSING-INFO) ; optional
    BODY...)
#+end_src

Here is an example of a function that multiplies its argument by seven:

#+begin_src emacs-lisp
  (defun multiply-by-seven (number)
    "Multiply NUMBER by seven."
    (* 7 number))
#+end_src

** Install a Function Definition
The process of evaluating a function definition (by running the
‘eval-last-sexp’, or typing ‘C-x C-e’ with the cursor immediately after the
definition) results in the installation of the function in Emacs’ namespace
(returning the name of the function itself).  The function can now be called
from within any expression.

*** Effect of Installation
Installing a function makes it available for use within Emacs.  The following
can now be evaluated:

#+begin_src emacs-lisp
  (multiply-by-seven 3) ; 21
#+end_src

#+RESULTS:
: 21

The documentation of a function definition can be inquired by invoking the
‘describe-function’ (‘C-h f’) command.

*** Change a Function Definition
To change or update a function definition, install the modified function
definition.  This will replace the former version in the namespace:

#+begin_src emacs-lisp
  (defun multiply-by-seven (number)     ; Second version
    "Multiply NUMBER by seven."
    (+ number number number number number number number))
#+end_src

Note that, in Lisp, everything that follows a semicolon in a line is a comment.

** Make a Function Interactive
A function is made interactive by placing a list that begins with the special
form ‘interactive’ immediately after the documentation.  A user can invoke an
interactive function by typing ‘M-x’ and then the name of the function; or by
typing the keys to which it is bound, for example, by typing ‘C-n’ for
‘next-line’ or ‘C-x h’ for ‘mark-whole-buffer’.

*** Interactive multiply-by-seven
Here is an example of an interactive version of ‘multiply-by-seven’:

#+begin_src emacs-lisp
  (defun multiply-by-seven (number)     ; Interactive version
    "Multiply NUMBER by seven."
    (interactive "p")
    (message "The result is %d" (* 7 number)))
#+end_src

Once installed, the function can now be used interactively by typing ‘C-u’ and a
number and then typing ‘M-x multiply-by-seven’ and pressing <RET>.  ‘The phrase
The result is …’ followed by the product will appear in the echo area.

An interactive function is invoked in one of two ways:

1. By typing a prefix argument that contains the number to be passed, and then
   typing ‘M-x’ and the name of the function, as with ‘C-u 3 M-x
   forward-sentence’; or,

2. By typing whatever key or keychord the function is bound to, as with ‘C-u 3
   M-e’.

Both the examples above work identically to move point forward three sentences.

A “prefix argument” is passed to an interactive function by typing the <META>
key followed by a number, for example, ‘M-3 M-e’, or by typing ‘C-u’ and then a
number, for example, ‘C-u 3 M-e’ (if you type ‘C-u’ without a number, it
defaults to 4).

*** multiply-by-seven in detail
In this function, the expression, ‘(interactive "p")’, is a list of two
elements.  The ‘"p"’ tells Emacs to pass the prefix argument to the function and
use its value for the argument of the function.

** Different Options for ‘Interactive’
Consider the function ‘zap-to-char’.  Its interactive expression is (or /was/,
at the time of the writing of the book):

#+begin_src emacs-lisp
  (interactive "p\ncZap to char: ")
#+end_src

The first part of the argument to ‘interactive’ is ‘p’, which tells Emacs to
interpret a prefix as a number to be passed to the function.  In the context of
‘zap-to-char’, the prefix is the number of specified characters to delete up
to.  Thus, if the prefix is three and the specified character is ‘x’, then the
call to the function will delete all the text up to and include the third next
‘x’.  Without a prefix, the functions deletes all the text up to and including
the specified character, but no more.

The ‘c’ tells the function the name of the character to which to delete.

The ‘interactive’ declaration is a special form of ‘C source code’ that
specifies a way of parsing arguments for interactive use of a function.  The
argument of ‘interactive’ is a string containing a code letter followed
optionally by a prompt.  To pass several arguments to the command, concatenate
the individual strings, separating them by newline characters.

Code letters available are:
+ a -- Function name: symbol with a function definition.
+ b -- Name of existing buffer.
+ B -- Name of buffer, possibly nonexistent.
+ c -- Character (no input method is used).
+ C -- Command name: symbol with interactive function definition.
+ d -- Value of point as number.  Does not do I/O.
+ D -- Directory name.
+ e -- Parameterized event (i.e., one that’s a list) that invoked this command.
  If used more than once, the Nth ‘e’ returns the Nth parameterized event.
  This skips events that are integers or symbols.
+ f -- Existing file name.
+ F -- Possibly nonexistent file name.
+ G -- Possibly nonexistent file name, defaulting to just directory name.
+ i -- Ignored, i.e. always nil.  Does not do I/O.
+ k -- Key sequence (downcase the last event if needed to get a definition).
+ K -- Key sequence to be redefined (do not downcase the last event).
+ m -- Value of mark as number.  Does not do I/O.
+ M -- Any string.  Inherits the current input method.
+ n -- Number read using minibuffer.
+ N -- Numeric prefix arg, or if none, do like code ‘n’.
+ p -- Prefix arg converted to number.  Does not do I/O.
+ P -- Prefix arg in raw form.  Does not do I/O.
+ r -- Region: point and mark as 2 numeric args, smallest first.  Does no I/O.
+ s -- Any string.  Does not inherit the current input method.
+ S -- Any symbol.
+ U -- Mouse up event discarded by a previous k or K argument.
+ v -- Variable name: symbol that is ‘custom-variable-p’.
+ x -- Lisp expression read but not evaluated.
+ X -- Lisp expression read and evaluated.
+ z -- Coding system.
+ Z -- Coding system, nil if no prefix arg.

** Install Code Permanently
Functions installed through evaluation are purged from memory upon quitting
Emacs.  In order to have code installed automatically whenever Emacs is started,
one needs to:

+ Write code into the ‘.emacs’ initialization file.  This file is automatically
  evaluated when Emacs is started and all the functions within it are installed.

+ Functions can also be written into one or more files of their own and then
  loaded via the ‘load’ function.  This causes Emacs to evaluate and thereby
  install each of the functions in the files.

+ For code that an entire site will use, it is customary to write it into a file
  called ‘site-init.el’ that is loaded when Emacs is built.  This makes the code
  available for everyone using that machine.

** let
The ‘let’ expression is a special form in Lisp that is used in most function
definitions.  ‘let’ is used to attach or bind a symbol within the scope of a function.

*** Prevent confusion
‘let’ creates a name for a “local variable” that overshadows any use of the same
name outside the ‘let’ expression.

Local variables created by a ‘let’ expression retain their value /only/ within
the ‘let’ expression itself (and within expressions called within the ‘let’
expression); the local variables have no effect outside the ‘let’ expression.

‘let’ is like a ‘setq’ that is temporary and local.  The values set by ‘let’ are
automatically undone when the ‘let’ is finished.  In Emacs Lisp, scoping is
dynamic, not lexical.

From the [[https://www.wikiwand.com/en/Scope_(computer_science)#/Lexical_scope_vs._dynamic_scope][Wikipedia]] entry on lexical scope vs. dynamic scope:

#+begin_quote
In languages with lexical scope (also called static scope), name resolution
depends on the location in the source code and the lexical context, which is
defined by where the named variable or function is defined.  In contrast, in
languages with dynamic scope the name resolution depends upon the program state
when the name is encountered which is determined by the execution context or
calling context.  In practice, with lexical scope a variable’s definition is
resolved by searching its containing block or function, then if that fails
searching the outer containing block, and so on, whereas with dynamic scope the
calling function is searched, then the function which called that calling
function, and so on, progressing up the call stack.
#+end_quote

*** Parts of let expression
A ‘let’ expression is a list of three parts.  This first part is the symbol
‘let’.  The second part is a list, called a “varlist”, each element of which is
either a symbol by itself or a two-element list, the first element of which is a
symbol.  The third part of the ‘let’ expression consists of one or more lists.

The following is a template for a ‘let’  expression:

#+begin_src emacs-lisp
  (let VARLIST BODY...)
#+end_src

The symbols in the varlist are the variables that are given initial values by
the ‘let’ special form.  Symbols by themselves are given the initial value of
‘nil’; and each symbol that is the first element of a two-element list is bound
to the value that is returned when the Lisp interpreter evaluates the second
element.

Thus, a varlist might look like this: ‘(thread (needles 3))’.  In this case, in
a ‘let’ expression, Emacs binds the symbol ‘thread’ to an initial value of
‘nil’, and binds the symbol ‘needles’ to an initial value of 3.

*** Sample let Expression
The following expression creates and gives initial values to the two variables
‘zebra’ and ‘tiger’.  The body of the ‘let’ expression is a list which calls the
‘message’ function:

#+begin_src emacs-lisp
  (let ((zebra "stripes")
        (tiger "fierce"))
    (message "One kind of animal has %s and another is %s."
             zebra tiger))
#+end_src

#+RESULTS:
: One kind of animal has stripes and another is fierce.

*** Uninitialized let Variables
If you do not bind the variables of a ‘let’ statement to specific initial
values, they will automatically be bound to an initial value of ‘nil’, as in the
following expression:

#+begin_src emacs-lisp
  (let ((birch 3)
        pine
        fir
        (oak 'some))
    (message
     "Here are %d variables with %s, %s, and %s value."
     birch pine fir oak))
#+end_src

#+RESULTS:
: Here are 3 variables with nil, nil, and some value.

** if
A third special form, in addition to ‘defun’ and ‘let’, is the conditional ‘if’.
This form is used to instruct the computer to make decisions.

*** if in more detail
An ‘if’ expression written in Lisp does not use the word “then”; the test and
the action are the second and third elements of the list whose first element is
‘if’.  Nonetheless, the test part of an ‘if’ expression is often called the
“if-part” and the second argument is often called the “then-part”.

Also, when an ‘if’ expression is written, the true-or-false-test is usually
written on the same line as the symbol ‘if’, but the action to carry out if the
test is true, the then-part, is written on the second and subsequent lines.
This makes the ‘if’ expression easier to read:

#+begin_src emacs-lisp
  (if TRUE-OR-FALSE-TEST
      ACTION-TO-CARRY-OUT-IF-TEST-IS-TRUE)
#+end_src

Here is an example:

#+begin_src emacs-lisp
  (if (> 5 4)                           ; if-part
  (message "Five is greater than four!")) ; then-part
#+end_src

#+RESULTS:
: Five is greater than four!

And a more realistic example:

#+begin_src emacs-lisp
  (defun type-of-animal (characteristic)
    "Print message in echo area depending on CHARACTERISTIC.
  If the CHARACTERISTIC is the string \"fierce\",
 then warn of a tiger."
    (if (equal characteristic "fierce")
        (message "It is a tiger!")))

  (type-of-animal "fierce")"It is a tiger!"
  (type-of-animal "striped")
#+end_src

*** type-of-animal in detail
‘if’ is a special form in ‘C source code’.

The template of and ‘if’ statement is:

#+begin_src emacs-lisp
  (if COND THEN ELSE...)
#+end_src

If COND yields non-nil, do THEN, else do ELSE...
Returns the value of THEN or the value of the last of the ELSE’s.
THEN must be one expression, but ELSE... can be zero or more expressions.
If COND yields nil, and there are no ELSE’s, the value is nil.

** else
An ‘if’ expression may have an optional third argument, called the “else-part”,
for the case when the true-or-false-test returns false.  When this happens, the
second argument or then-part of the overall ‘if’ expression is /not/ evaluated,
but the third or else-part /is/ evaluated.

In the written Lisp, the else-part is usually written to start on a line of its
own and is indented less than the then-part:

#+begin_src emacs-lisp
  (if TRUE-OR-FALSE-TEST
         ACTION-TO-CARRY-OUT-IF-THE-TEST-RETURNS-TRUE
       ACTION-TO-CARRY-OUT-IF-THE-TEST-RETURNS-FALSE)
#+end_src

Here is an example:

#+begin_src emacs-lisp
  (if (> 4 5)                        ; if-part
      (message "Four falsely greater than five!") ; then-part
      (message "Four is not greater than five!"))   ; else-part
#+end_src

#+RESULTS:
: Four is not greater than five!

And a more elaborated example with the ‘type-of-animal’ function:

#+begin_src emacs-lisp
  (defun type-of-animal (characteristic)  ; Second version.
    "Print message in echo area depending on CHARACTERISTIC.
  If the CHARACTERISTIC is the string \"fierce\",
  then warn of a tiger; else say it is not fierce."
    (if (equal characteristic "fierce")
        (message "It is a tiger!")
      (message "It is not fierce!")))

  (type-of-animal "fierce")"It is a tiger!"
  (type-of-animal "striped")"It is not fierce!"
#+end_src

** Truth & Falsehood
In Lisp, the predicate “false” is represented by the symbol ‘nil’.  Anything
else (anything at all) is “true”.

The expression that tests for truth is interpreted as “true” if the result of
evaluating it is a value that is not ‘nil’.  In other words, the result of the
test is considered true if the value returned is a number such as 42, a string
such as ‘"hello"’, or a symbol (other than ‘nil’) such as ‘flowers’, or a list
(so long as it is not empty), or even a buffer.  If some other useful value is
not available for the test that returns true, then the Lisp interpreter will
return the symbol ‘t’ for true (see example under the following headline).

*** nil explained
In Emacs Lisp, the symbol ‘nil’ has two meanings.  First, it means the empty
list.  Second, it means false and is the value returned when a
true-or-false-test tests false.  ‘nil’ can be written as an empty list, ‘()’, or
as ‘nil’.  As far as the Lisp interpreter is concerned, ‘()’ and ‘nil’ are the
same:

#+begin_src emacs-lisp
  (equal () nil)
#+end_src

#+RESULTS:
: t

** save-excursion
The ‘save-excursion’ function is a special form that saves the location of the
point, executes the body of the function, and then restores point to its
previous position if its location has changed.

*** Point and mark
“Point” is the current location of the cursor.  More precisely, on terminals
where the cursor appears to be on top of a character, point is the immediately
before the character.  In Emacs Lisp, point is an integer.  The function ‘point’
returns the current position of the cursor as a number.  Each buffer has its own
value for point.

The “mark” is another position in the buffer; its value can be set with a
command such as ‘set-mark-command’ (‘C-<SPC>’).  If a mark has been set, the
command ‘exchange-point-and-mark’ (‘C-x C-x’) causes the cursor to jump to the
mark and set the mark to be the previous position of point.  In addition,
setting another mark saves the position of the previous mark in the mark ring.
Many mark positions can be saved this way.  The prefixed command ‘C-u C-<SPC>’
will jump to mark, and set the mark from position popped off the local mark
ring.  Thus, successive invocations of ‘C-u C-<SPC>’ will sequentially jump to
each previous positions of the mark kept in the mark ring.

The part of the buffer between point and mark is called “the region”.  Numerous
commands work on the region, including ‘center-region’, ‘count-lines-region’,
‘kill-region’, and ‘print-region’.

The ‘save-excursion’ special form saves the location of point and restores this
position after the cod ewithin the body of the special form is evaluated by the
Lisp interpreter.

*** Template for save-excursion
The template for save-excursion is as follows:

#+begin_src emacs-lisp
  (save-excursion
    BODY...)
#+end_src

The body of the function is one or more expressions that will be evaluated in
sequence by the Lisp interpreter.  If there is more than one expression in the
body, the value of the last one will be returned as the value of the
‘save-excursion’ function.  The other expressions in the body are evaluated only
for their side effects; and ‘save-excursion’ itself is used only for its side
effect (which is restoring the position of point).

In Emacs Lisp code, a ‘save-excursion’ expression often occurs within the body
of a ‘let’ expression:

#+begin_src emacs-lisp
  (let VARLIST
    (save-excursion
      BODY...))
#+end_src

** Review
This is a review of the macros, function definitions and special forms covered
so far.

*** ‘eval-last-sexp’
Evaluate the last symbolic expression before the current location of point.  The
value is printed in the echo area unless the function is invoked with an
argument; in that case, the output is printed in the current buffer.  This
command is normally bound to ‘C-x C-e’.

*** ‘defun’
Define function.  This macro has up to five parts: the name, a template for the
arguments that will be passed to the function, documentation, an optional
interactive declaration, and the body of the definition.

For example, in Emacs the funciton definition of ‘dired-unmark-all-marks’ is as
follows.

#+begin_src emacs-lisp
  (defun dired-unmark-all-marks ()
    "Remove all marks from all files in the Dired buffer."
    (interactive)
    (dired-unmark-all-files ?\r))
#+end_src

*** ‘interactive’
Declare to the interpreter that the function can be used interactively.  This
special form may be followed by a string with one or more parts that pass the
information to the arguments of the function, in sequence.  These parts may also
tell the interpreter to prompt for information.  Parts of the string are
separated by newlines, ‘\n’.

Common code characters are:

+ ‘b’: The name of an existing buffer.
+ ‘f’: The names of an existing file.
+ ‘p’: The numeric prefix argument.  (Note that this ‘p’ is lower case.)
+ ‘r’: Point and the mark, as two numeric arguments, smallest first.  This is
  the only code letter that specifies two successive arguments rather than one.

*** ‘let’
Declare that the list of variables is for use within the body of the ‘let’ and
give them an initial value, either ‘nil’ or a specified value; then evaluate the
rest of the expressions in the body of the ‘let’ and return the value of the
last one.  Inside the body of the ‘let’, the Lisp interpreter does not see the
values of the variables of the same names that are bound outside of the ‘let’.

For example,

#+begin_src emacs-lisp
  (let ((foo (buffer-name))
        (bar (buffer-size)))
    (message
     "This buffer is %s and has %d characters."
     foo bar))
#+end_src

*** ‘save-excursion’
Record the values of point and the current buffer before evaluating the body of
this special form.  Restore the value of point and buffer afterwards.

For example,

#+begin_src emacs-lisp
  (message "We are %d characters into this buffer."
           (- (point)
              (save-excursion
                (goto-char (point-min))
                (point))))
#+end_src

#+RESULTS:
: We are 39114 characters into this buffer.

*** ‘if’
Evaluate the first argument to the function; if it is true, evaluate the seconds
argument; else evaluate the third argument, if there is one.

The ‘if’ special form is called “conditional”.  There are other conditionals in
Emacs Lisp, but ‘if’ is perhaps the most commonly used.

For example,

#+begin_src emacs-lisp
  (if (= 22 emacs-major-version)
      (message "This is version 22 of Emacs.")
    (message "This is not version 22 of Emacs."))
#+end_src

*** ‘<’, ‘>’, ‘<=’ & ‘>=’
The ‘<’ function tests whether its first argument is smaller than its second
argument.  A corresponding function, ‘>’, tests whether the first argument is
greater than the second.  Likewise, ‘<=’ tests whether the first argument is
less than or equal to the second and ‘>=’ tests whether the first argument is
greater than or equal to the second.  In all cases, both arguments must be
numbers or markers (markers indicate positions in buffers).

*** ‘=’
The ‘=’ function tests whether two arguments, both numbers or markers, are
equal.

*** ‘equal’ & ‘eq’
Tests whether two objects are the same.  ‘equal’ uses one meaning of the word
“same” and ‘eq’ uses another: ‘equal’ returns true if the two objects have a
similar structure and contents, such as two copies of the same book.  On the
other hand, ‘eq’ returns true if both arguments are actually the same object.

*** ‘string<’, ‘string-lessp’, ‘string=’ & ‘string-equal’
The ‘string-lessp’ function tests whether its first argument is smaller than the
second argument.  A shorter, alternative name for the same function (a
‘defalias’) is ‘string<’.

The arguments to ‘string-lessp’ must be strings or symbols; the ordering is
lexicographic, so case is significant.  The print names of symbols are used
insteada of the symbols themselves.

An empty string, ‘""’, a string with no characters in it, is smaller than any
string of characters.

‘string-equal’ provides the corresponding test for equality.  Its shorter
alternative name is ‘string=’.  There are no string test functions that
correspond to ‘>’, ‘>=’, or ‘<=’.

*** ‘message’
Print a message in the echo area.  The first argument is a string that can
contain ‘%s’, ‘%d’, or ‘%c’ to print the value of arguments that follow the
string.  The argument used by ‘%s’ must be a string or a symbol; the argument
used by ‘%d’ must be a number.  The argument used by ‘%c’ must be an ASCII code
number; it will be printed as the character with that ASCII code.  (Various
other %-sequences also exist.)

*** ‘setq’ & ‘set’
The ‘setq’ function sets the value of its first argument to the value of the
second argument.  The first argument is automatically quoted by ‘setq’.  It does
the same for suceeding pairs of arguments.  Another function, ‘set’, takes only
two arguments and evaluates both of them before setting the value returned by
its first argument to the value returned by its second argument.

*** ‘buffer-name’
Without an argument, return the name of the buffer, as a string.

*** ‘buffer-file-name’
Without an argument, return the name of the file the buffer is visiting.

*** ‘current-buffer’
Return the buffer in which Emacs is active; it may not be the buffer that is
visible on screen.

*** ‘other-buffer’
Return the most recently selected buffer (other than the buffer passed to
‘other-buffer’ as an argument and other than the current buffer).

*** ‘switch-to-buffer’
Select a buffer for Emacs to be active in and display it in the current window
so users can look at it.  Usually bound to ‘C-x b’.

*** ‘set-buffer’
Switch Emacs’s attention to a buffer on which programs will run.  Don’t alter
what the window is showing.

*** ‘buffer-size’
Return the number of characters in the current buffer.

*** ‘point’
Return the value of the current position of the cursor, as an integer counting
the number of characters from the beginning of the buffer.

*** ‘point-min’
Return the minimum permissible value of point in the current buffer.  This is
one, unless narrowing is in effect.

*** ‘point-max’
Return the value of the maximum permissible value of point in the current
buffer.  This is the end of the buffer, unless narrowing is in effect.

** Exercises
*** Exercise 3.1
Write a non-interactive function that doubles the value of its argument, a
number.  Make that function interactive.

#+begin_src emacs-lisp
  (defun double-me (number)             ; non-interactive version
    "Returns twice the value of NUMBER."
    (* 2 number))

  (double-me 3) ; 6

  (defun double-me (number)             ; interactive-version
    "Returns twice the value of NUMBER."
    (interactive "p")
    (message "%d is twice the value of %d"
             (* 2 number)
             number))
#+end_src

*** Exercise 3.2
Write a function that tests whether the current value of ‘fill-column’ is
greater than the argument passed to the function, and if so, prints an
appropriate message.

#+begin_src emacs-lisp
  (defun fill-column-compare (number)
    "Compares value of NUMBER with the value of `fill-column'."
    (interactive "p")
    (if (> fill-column number)
        (message "The number %d is lesser than the value of `fill-column' (%d)"
                 number fill-column)
      (message "The number %d is equal or bigger than the value of `fill-column' (%d)"
               number fill-column)))
#+end_src

* Buffer Walk Through
This chapter covers some GNU Emacs buffer-related functions.

** Finding More
Emacs Lisp function are documented.  Their documentation can be reached via the
command ‘describe-function’ (bound to ‘C-h f’).  Similarly, the full
documentation of a variable can be perused via the command ‘describe-variable’
(bound to ‘C-h v’).

To enquire a function’s original source file, refer to the function
‘xref-find-definitions’.  ‘xref-find-definitions’ works with a variety of
languages, not just Lisp and C, and it works with non-programming text as well.
For example, ‘xref-find-definitions’ will jump to the various nodes in the
Texinfo source file of an Info document (provided that the ‘etags’ utility was
run to record all the nodes in the manuals that comes with Emacs).

** A Simplified ‘beginning-of-buffer’ Definition
As an interactive command, ‘beginning-of-buffer’ moves the cursor to the
beginning of the buffer, leaving the mark at the previous position.  It is
generally bound to ‘M-<’.

Here is a simplified version of the actual function definition:

#+begin_src emacs-lisp
  (defun simplified-beginning-of-buffer ()
    "Move point to the beginning of the buffer;
  leave mark at previous position."
    (interactive)
    (push-mark)
    (goto-char (point-min)))
#+end_src

** The Definition of ‘mark-whole-buffer’
The ‘mark-whole-buffer’ funciton marks a while buffer as a region by putting
point at the beginning and a mark at the end of the buffer.  It is generally
bound to ‘C-x h’.

*** ‘mark-whole-buffer’ overview
In GNU Emacs 22, the code for the complete function looks like this:

#+begin_src emacs-lisp
  (defun mark-whole-buffer ()
    "Put point at beginning and mark at end of buffer.
  You probably should not use this function in Lisp programs;
  it is usually a mistake for a Lisp function to use any subroutine
  that uses or sets the mark."
    (interactive)
    (push-mark (point))
    (push-mark (point-max) nil t)
    (goto-char (point-min)))
#+end_src

*** Body of ‘mark-whole-buffer’
In the line,

#+begin_src emacs-lisp
  (push-mark (point-max) nil t)
#+end_src

the first argument, ‘(point-max)’, tells the function to set the mark at the
point in the buffer that has the highest number.  The second argument, ‘nil’,
instructs the function to display a message that says “Mark set” when it pushes
the mark.  The third argument, ‘t’, tells ‘push-mark’ to activate the mark when
Transient Mark mode is turned on.  Transient Mark mode highlights the current
active region (it often turned off).

** The Definition of ‘append-to-buffer’
The ‘append-to-buffer’ command copies the region (that is, the part of the
buffer between point and mark) from the current buffer to a specified buffer.

*** An Overview of ‘append-to-buffer’
The ‘append-to-buffer’ command uses the ‘insert-buffer-substring’ function to
copy the region.  ‘insert-buffer-substring’ takes a substring from a buffer, and
inserts it into another buffer.

Here is the text of the ‘append-to-buffer’ function (at the date of the writing
of the book; it has since been amended):

#+begin_src emacs-lisp
  (defun append-to-buffer (buffer start end)
    "Append to specified buffer the text of the region.
  It is inserted into that buffer before its point.

  When calling from a program, give three arguments:
  BUFFER (or buffer name), START and END.
  START and END specify the portion of the current buffer to be copied."
    (interactive
     (list (read-buffer "Append to buffer: " (other-buffer
                                              (current-buffer) t))
           (region-beginning) (region-end)))
    (let ((oldbuf (current-buffer)))
      (save-excursion
        (let* ((append-to (get-buffer-create buffer))
               (windows (get-buffer-window-list append-to t t))
               point)
          (set-buffer append-to)
          (setq point (point))
          (barf-if-buffer-read-only)
          (insert-buffer-substring oldbuf start end)
          (dolist (window windows)
            (when (= (window-point window) point)
              (set-window-point window (point))))))))
#+end_src

The function has three arguments: the ‘buffer’ to which the text will be copied,
and the ‘start’ and the ‘end’ of the region in the current buffer that will be
copied.  As stated in the documentation, the function can handle both the
destination buffer and its name.

*** The ‘append-to-buffer’ Interactive Expression
The interactive expression contains a list composed of three parts.  The first
part of this list is an expression to read the name of a buffer and return it as
a string.  This is achieved through the function ‘read-buffer’.  This functions
requires a prompt as its first argument, ‘"Append to buffer: "’.  Its second
argument tells the command what value to provide if nothing is specified.

This fallback argument is an expression calling the function ‘other-buffer’, an
exception, and the symbol ‘t’, standing for true.  This means that, should the
user not provide a buffer to append the region to, the function will take the
most recent buffer other than the current buffer (regardless of whether it is
visible or not) as its BUFFER argument.

*** The Body of ‘append-to-buffer’
The body of the function is wrapped in a ‘let’ statement.  This statement binds
the value returned by ‘(current-buffer)’ to the variable ‘oldbuf’.  This
variable will be used to keep track of the current working buffer.

*** ‘save-excursion’ in ‘append-to-buffer’
The body of the ‘let’ expression in ‘append-to-buffer’ consists of a
‘save-excursion’ expression.

The body of the ‘save-excursion’ expression is itself wrapped in a ‘let*’
expression.  This command behaves in the same manner as the ‘let’ special form,
except that it allows for variables set later in its VARLIST to make use of the
values to which Emacs set variables earlier in the VARLIST.

The ‘set-buffer’ function makes its argument (expressed as a buffer or a buffer
name) current for editing operations.  The variable ‘append-to’ is fed as an
argument to the ‘set-buffer’ call; this variable is bound to
‘(get-buffer-create buffer)’ earlier in the ‘let*’ expression.

The function that does the actual job is ‘insert-buffer-substring’.  Because
this function copies text /from/ a specified third party buffer to the current
buffer (the reverse operation we want to perform), ‘append-to-buffer’ first
switches focus to the destination buffer, making it the current one.  Then it
makes a call to ‘insert-buffer-substring’, taking text from ‘oldbuf’ (the one
from which the call to ‘append-to-buffer’ is issued) to the buffer designated as
‘append-to’.

Once the string is appended, focus is returned to the starting buffer through
the closing of the ‘save-excursion’ expression.

Written in skeletal form, the workings of the ‘append-to-buffer’ function look
like this:

#+begin_src emacs-lisp
  (let (BIND-oldbuf-TO-VALUE-OF-current-buffer)
    (save-excursion                       ; Keep track of buffer.
      CHANGE-BUFFER
      INSERT-SUBSTRING-FROM-oldbuf-INTO-BUFFER)

    CHANGE-BACK-TO-ORIGINAL-BUFFER-WHEN-FINISHED
    LET-THE-LOCAL-MEANING-OF-oldbuf-DISAPPEAR-WHEN-FINISHED)
#+end_src

** Review
Here is a summary of the functions covered in this chapter.

*** ‘describe-function’ & ‘describe-variable’
Print the documentation for a function or variable.  Conventionally bound to
‘C-h f’ and ‘C-h v’.

*** ‘xref-find-definitions’
Find the file containing the source for a function or variable and switch
buffers to it, positioning point at the beginning of the item.  Conventionally
bound to ‘M-.’.

*** ‘save-excusrion’
Save the location of point and restore its value after the arguments to
‘save-excusrion’ have been evaluated.  Also, remember the current buffer and
return to it.

*** ‘push-mark’
Set mark at a location and record the value of the previous mark on the mark
ring.  The mark is a location in the buffer that will retain its relative
position even if text is added to or removed from the buffer.

*** ‘goto-char’
Set point to the location specified by the value of the argument, which can be a
numberm a marker, or an expression that returns the number of a position, such
as ‘(point-min)’.

*** ‘insert-buffer-substring’
Copy a region of text from a buffer that is passed to the function as an
argument and insert the region into the current buffer.

*** ‘mark-whole-buffer’
Mark the whole buffer as a region.  Normally bound to ‘C-x h’.

*** ‘set-buffer’
Switch the focus of Emacs to another buffer, but do not change the window being
displayed.  Used when the program rather than a human it to work on a different buffer.

*** ‘get-buffer-create’ & ‘get-buffer’
Find a named buffer or create one if a buffer of that name does not exist.  The
‘get-buffer’ function returns ‘nil’ if the named buffer does not exist.

** Exercises
*** Exercise 4.1
Write a ‘simplified-end-of-buffer’ function; then test to see whether it works.

#+begin_src emacs-lisp
  (defun simplified-end-of-buffer ()
      "Go the the end of the buffer."
    (interactive)
    (goto-char (point-max)))
#+end_src

*** Exercise 4.2
Use ‘if’ and ‘get-buffer’ to write a function the prints a message telling
whether a buffer exists.

#+begin_src emacs-lisp
  (defun is-bufferp (buffer)
    "Determines whether buffer BUFFER exists."
    (interactive "BBuffer:")
    (if (get-buffer buffer)
        (message "Buffer %s does exist!" buffer)
      (message "Buffer %s does not exist." buffer)))
#+end_src

*** Exercise 4.3
Using ‘xref-find-definitions’, find the source for the ‘copy-to-buffer’
function.

#+begin_src emacs-lisp
  (xref-find-definitions 'copy-to-buffer)
#+end_src

* More Complex
* Narrowing & Widening
* car cdr & cons
* Cutting & Storing Text
* List Implementation
* Yanking
* Loops & Recursion
* Regexp Search
* Counting Words
* Words in a defun
* Readying a Graph
* Emacs Initialization
* Debugging
* Conclusion
* the-the
* Kill Ring
* Full Graph
* Free Software and Free Manuals
* GNU Free Documentation License

#+STARTUP: content

* List Processing
Lisp stands for “Lots of Isolated Silly Parentheses”.  Or, more prosaically,
“LISt Processing”.  Lists are contained within parentheses.  Lists are the basis
of Lisp.

** Lisp Lists
This is a Lisp list:
#+begin_src emacs-lisp
  '(rose
    violet
    daisy
    buttercup)
#+end_src

#+RESULTS:
| rose | violet | daisy | buttercup |

*** Numbers, List inside Lists
Here is another list, this time with a list inside of it:
#+begin_src emacs-lisp
  '(this list has (a list inside of it))
#+end_src

#+RESULTS:
| this | list | has | (a list inside of it) |

*** Lisp Atoms
The empty list, ‘()’, is considered both an atom and a list at the same time.
“Symbolic expressions” or, more concisely, “s-expressions”, are the printed
representation of both atoms and lists.  Also, the word “form” can be used as a
synonym for expression.

Atoms are indivisible semantic units.  Numbers and symbols are examples of
atoms.  Text betwen double quotation marks (even sentences or paragraphs) is
also an atom.  Here is an example:
#+begin_src emacs-lisp
  '(this list includes "text between quotation marks.")
#+end_src

#+RESULTS:
| this | list | includes | text between quotation marks. |

This kind of atom is called a “string” (for “string of characters”).

*** Whitespace in Lists
The amount of whitespace in a list does not matter.

In brief, a list is between parentheses, a string is between quotation marks, a
symbol looks like a word, and a number looks like a number.

** Run a Program
The Lisp interpreter will evaluate a list unless it is preceded by a quote
(‘'’).  If quoted, the list is returned as is:

#+begin_src emacs-lisp
  '(this is a quoted list)
#+end_src

#+RESULTS:
| this | is | a | quoted | list |

If unquoted, the interpreter will take the first item of the list as a function
to execute, with the remaining elements of the list taken as arguments:

#+begin_src emacs-lisp
  (+ 2 2)
#+end_src

#+RESULTS:
: 4

** Making Errors
Alternatively, if the list is not compliant with the language syntax, an error
message is returned by the GNU Emacs debugger:

#+begin_src emacs-lisp
  (this is an unquoted list)
#+end_src

This instruction will invoke the debugger, which is opened in a buffer named
*Backtrace*.  To quit the debugger, type ‘q’.  The *Backtrace* shows the series
of steps that the interpreter took to evaluate the given s-expression, from the
bottom up.  The last of these messages, at the top of the *Backtrace* buffer,
conveys the absence of an instruction registered with the symbol ‘this’; in
other words, there is no function that can be executed by this list.  Thus,
‘this’ is a ‘void-function’.

** Names & Definitions
A function may have different symbols associated to it (e.g., ‘+’ anld ‘plus’ both
can refer to the set of instructions used to add numbers).  Conversely, a symbol
can have only one function associated to it at a time.

As Emacs only has one namespace, it is customary to name symbols in a way that
identifies the function with the feature of Emacs it is associated with.  Thus,
all the names for functions related to Texinfo start with ‘texinfo-’ and those
for functions that deal with reading mail start with ‘rmail-’.

** Lisp Interpreter
The Lisp interpreter first looks to see whether there is a quote before the
list; if there is, the interpreter just returns a list.  If there is no quote,
the interpreter looks at the first element olf the list and sees whether it has a
function definition.  If it does, the interpreter carries the instructions in
the function definition.  Otherwise, the interpreter prints an error message.

*** Complications
In addition to these case scenarios, the Lisp interpreter can evaluate a symbol
that is not quoted and does not have parentheses around it.  In this case, the
interpreter will attempt to determine the symbol’s value as a “variable”.

There is also an exception for unusual functions called “special forms”.  They
are used for special tasks, like defining a function, and there are not many of
them.

As well as special forms, there are also “macros”.  A macro is a construct
defined in Lisp, which differs from a function in that it translates a Lisp
expression into another expression that is to be evaluated in place of the
original expression.

The Lisp interpreter evaluates nested lists from the inside out, i.e., first it
evaluates the innermost list (the result of which can be used in the evaluation
of the enclosing expression), up to the outermost list.

*** Bite Compiling
The Lisp interpreter is able to interpret human readable code as well as byte
compiled code.  Bite compiled code is usually stored in a file with an ‘.elc’
extension, as opposed to a ‘.el’ extension, reserved for human readable code.

** Evaluation
“To ascertain the value or amount of; to appraise”, according to ‘Webster’s New
Collegiate Dictionary’.

*** How the Interpreter Acts
Evaluating a symbolic expression most commonly causes the Lisp interpreter to
return a value and perhaps carry out a side effect; or else produce an error.

*** Evaluating Inner Lists
In nested lists, the innermost list is evaluated first and its returning value
is passed to the enclosing list.  The outer expressions are then successively
evaluated (if any), up to the outermost list:

#+begin_src emacs-lisp
  (+ 2 (+ 3 3))
#+end_src

#+RESULTS:
: 8

** Variables
In Emacs Lisp, a symbol can have a value attached to it just as it can have a
function definition attached to it.  The value of a symbol can be any expression
in Lisp, such as a symbol, number, list of string.  A symbol that has a value is
often called a “variable”.  A symbol can have both a function definition and a
value attached to it at the same time.

*** fill-column example
In order to find the value attached to a variable, one needs to evaluate its
symbol:

#+begin_src emacs-lisp
fill-column
#+end_src

#+RESULTS:
: 80

*** Void Function
Note that, in the previous example, the symbol ‘fill-column’ was evaluated by
itself, and not within the context of a list.  This is because if it were
evaluated within a list, the Lisp interpreter would attempt to find the function
definition attached to it, when ‘fill-column’ has no function definition:

#+begin_src emacs-lisp
(fill-column)
#+end_src

This expression will generate a *Backtrace* buffer stating that the symbol
‘fill-column’ is a “void function”.

*** Void Variable
In addition, evaluating a symbol that does not have a value bound to it also
generates an error message.  For instance, in the following expression:

#+begin_src emacs-lisp
(+ 2 2)
#+end_src

running the command ‘eval-last-sexp’ (‘C-x C-e’), with the cursor right after
the ‘+’, will generate a *Backtrace* buffer stating that the symbol ‘+’ is a
“void variable”.  This is because the interpreter sought to look for the value
of a variable, by virtue of the fact that the “last expression” evaluated was
the symbol ‘+’, and not a list in which the first element would then be
interpreted as a function definition.

** Arguments
In Lisp, the arguments to a function are the atoms or lists that follow the
function.  The values returned by the evaluation of these atoms or lists are
passed to the function.  Different functions require different numbers of
arguments; some functions require none at all.

*** Data types
The type of data that should be passed to a function depends on what kind of
information it uses.  For example, the ‘concat’ function links together two or
more strings of text to produce a string.  The arguments are strings:

#+begin_src emacs-lisp
  (concat "abc" "def")
#+end_src

#+RESULTS:
: abcdef

The function ‘substring’ takes two types of arguments, a string and up to two
numbers that delimit the substring to return:

#+begin_src emacs-lisp
  (substring "The quick brown fox jumped." 16 19)
#+end_src

#+RESULTS:
: fox

Note that the string passed to ‘substring’ is a single atom even though it is
made up of several words separated by spaces.

*** An Argument as the Value of a Variable or List
An argument can be a symbol that returns a value when it is evaluated.  For
example, when the symbol ‘fill-column’ by itself is evaluated, it returns a
number.  This number can be used in an addition:

#+begin_src emacs-lisp
  (+ 2 fill-column)
#+end_src

#+RESULTS:
: 82

In addition, an argument can be a list that returns a value when it is
evaluated:

#+begin_src emacs-lisp
  (concat "The " (number-to-string (+ 2 fill-column)) " red foxes.")
#+end_src

#+RESULTS:
: The 82 red foxes.

*** Variable Number of Arguments
Some functions, such as ‘concat’, ‘+’ or ‘*’, take any number of arguments:

#+begin_src emacs-lisp
  (+) ; 0
  (*) ; 1
  (+ 3) ; 3
  (* 3) ; 3
  (+ 3 4 5) ; 12
  (* 3 4 5) ; 60
#+end_src

*** Wrong Type of Argument
When a function is passed  an argument of the wrong type, the Lisp interpreter
produces an error message.  For instance, the following example:

#+begin_src emacs-lisp
  (+ 2 'hello)
#+end_src

will produce a *Backtrace* buffer stating that the argument is of the wrong
type.  More specifically, the debugger message implies that the symbol passed as
argument (the quoted symbol ‘hello’) failed the “number or marker” test (a
marker is a special object representing a buffer position).

The ‘p’ of ‘number-or-marker-p’ stands for “predicate”.  A predicate is a
function to determine if some property is true or false.  Other Lisp symbols
that end in ‘p’ include ‘zerop’, a function that tests whether its argument has
the value of zero, and ‘listp’, a function that tests whether its argument is a
list.

*** The ‘message’ function
The ‘message’ function takes a variable number of arguments and is used to post
messages in the echo aread to the user:

#+begin_src emacs-lisp
  (message "This message appears in the echo area!")
#+end_src

#+RESULTS:
: This message appears in the echo area!

The format control strings ‘%s’ and ‘%d’ in the quoted string of characters are
replaced in the returned message respectively by string and integer arguments,
in the order that they appear in the argument list passed to the function:

#+begin_src emacs-lisp
  (message "The name of this buffer is: %s." (buffer-name))
#+end_src

#+RESULTS:
: The name of this buffer is: eintr.org.

#+begin_src emacs-lisp
  (message "The value of fill-column is: %d." fill-column)
#+end_src

#+RESULTS:
: The value of fill-column is: 80.

Here are two more complex examples:

#+begin_src emacs-lisp
  (message "There are %d %s in the office!"
           (- fill-column 14) "pink elephants")
#+end_src

#+RESULTS:
: There are 66 pink elephants in the office!

#+begin_src emacs-lisp
  (message "He saw %d %s"
           (- fill-column 32)
           (concat "red "
                   (substring
                    "The quick brown foxes jumped." 16 21)
                   " leaping."))
#+end_src

#+RESULTS:
: He saw 48 red foxes leaping.

** set & setq
One way by which to “bind” a variable to a value is to use either the function
‘set’ or the function ‘setq’.  Another way is to use the special form ‘let’.

*** Using set
When evaluated, the following expression will set the value of the symbol
‘flowers’ to the list ‘'(rose violet daisy buttercup)’:

#+begin_src emacs-lisp
  (set 'flowers '(rose violet daisy buttercup))
#+end_src

#+RESULTS:
| rose | violet | daisy | buttercup |

This happens as a side effect of returning the list itself.  Once set,
evaluating the symbol flowers will return the list it was assigned:

#+begin_src emacs-lisp
  flowers
#+end_src

#+RESULTS:
| rose | violet | daisy | buttercup |

However, evaluating the quoted symbol ‘'flowers’ will return the symbol itself:

#+begin_src emacs-lisp
  'flowers
#+end_src

#+RESULTS:
: flowers

*** Using setq
The special form ‘setq’ behaves like ‘set’ except that the first argument is
quoted automatically:

#+begin_src emacs-lisp
  (setq carnivores '(lion tiger leopard))
#+end_src

#+RESULTS:
| lion | tiger | leopard |

In addition, setq allows for the binding of several symbol/value pairs within
the same expression, by having each even argument bound to the preceding odd
symbol:

#+begin_src emacs-lisp
  (setq trees '(pine fir oak maple)
        herbivores '(gazelle antelope zebra))
#+end_src

#+RESULTS:
| gazelle | antelope | zebra |

*** Counting
Here is an example that shows how to use ‘setq’ in a counter:

#+begin_src emacs-lisp
  (setq counter 0)                      ; The initializer
  (setq counter (+ counter 1))          ; The incrementer
  counter                               ; The counter
#+end_src

** Summary
+ Lisp programs are made up of expressions, which are lists or single atoms.

+ Lists are made up of zero or more atoms or inner lists, separated by
  whitespace and surrounded by parentheses.  A list can be empty.

+ Atoms are multi-character symbols, like ‘forward-paragraph’, single character
  symbols like ‘+’, strings of characters between double quotation marks, or
  numbers.

+ A number evaluates to itself.

+ A string between double quotes evaluates to itself.

+ A symbol evaluated by itself returns its value.

+ When a list is evaluated, the Lisp interpreter looks at the first symbol in
  the list and then at the function definition bound to that symbol.  Then the
  instructions in the function definition are carried out.

+ The single quote ‘'’ tells the Lisp interpreter that it should return the
  following expression as written, and not evaluate it as it would if the quote
  were not there.

+ Arguments are the information passed to a function.  The arguments to a
  function are computed by evaluating the rest of the elements of the list of
  which the function is the first element.

+ A function always retuns a value when it is evaluated (unless it gets an
  error); in addition, it may also carry out some action that is a side effect.
  In many cases, a function’s primary purpose is to create a side effect.

** Exercises
*** Exercise 1.1
Generate an error message by evaluating an appropriate symbol that is not
within parentheses.

#+begin_src emacs-lisp
symbol
#+end_src

*** Exercise 1.2
Generate an error message by evaluating an appropriate symbol that is between
parentheses.

#+begin_src emacs-lisp
  (fill-column)
#+end_src

*** Exercise 1.3
Create a counter that increments by two rather than one.

#+begin_src emacs-lisp
  (setq counter2 0)
  (setq counter2 (+ counter2 2))
  counter2
#+end_src

*** Exercise 1.4
Write an expression that prints a message in the echo area when evaluated.

#+begin_src emacs-lisp
  (message "Exercises from chapter one are completed!")
#+end_src

* Practicing Evaluation
Symbol and lists can be evaluated.  When evaluating a list, the Lisp interpreter
looks for a function definition for its first element.  The instructions of the
function definition are then carried out with the arguments provided by the
subsequent elements of the list.

** How to Evaluate
In Emacs, editing commands are executed via the evaluation of an expression, the
first element of which is a function.  For instance, typing plain text is
achieved through the evaluation of an Emacs Lisp function,
‘self-insert-command’.  Such functions are called “interactive” functions, or
“commands”.

Another way to evaluate an expression is by running the command
‘eval-last-sexp’, which can be done by positioning the cursor after a list and
typing ‘C-x C-e’.

** Buffer Names
The difference between file and buffer is illustrated by the functions
‘buffer-name’ and ‘buffer-file-name’.  While evaluating the expression
‘(buffer-name)’ returns the name of the current buffer, evaluating
‘(buffer-file-name)’ retrieves the full path-name of the file:

#+begin_src emacs-lisp
  (buffer-name) ; "eintr.org[emacs-lisp]"

  (buffer-file-name) ; "/home/gtomas/Documents/programming/emacs-lisp/org/eintr/eintr.org"
#+end_src

** Getting Buffers
The ‘buffer-name’ function returns the /name/ of the buffer; to get the buffer
/itself/, the ‘current-buffer’ function is used.  Upon evaluation of this
function, the current buffer is returned as a lisp object; this is done as a
side effect of returning a specially formatted form of the buffer’s name:

#+begin_src emacs-lisp
  (current-buffer) ; #<buffer eintr.org[emacs-lisp]>
#+end_src

A related function is ‘other-buffer’.  This returns the most recently selected
buffer (that is not visible in another window) other than the one currently in
focus:

#+begin_src emacs-lisp
  (other-buffer) ; #<buffer *eshell*>
#+end_src

** Switching Buffers
The ‘other-buffer’ function provides a buffer when it is used as an argument to
a function that requires one.  It can thus be fed to the function
‘switch-to-buffer’:

#+begin_src emacs-lisp
  (switch-to-buffer (other-buffer))
#+end_src

This will skip any buffer currently displayed.  To move to the most recent
buffer, regardless of whether the buffer is already displayed in frame, the
following expression needs to be evaluated:

#+begin_src emacs-lisp
  (switch-to-buffer (other-buffer (current-buffer) t))
#+end_src

‘set-buffer’ achieves a similar goal to ‘switch-to-buffer’, with one difference:
it does not display the buffer itself (it us thus best suited for programmatic
purposes instead).

** Buffer Size & Locations
The function ‘buffer-size’ returns the size of the current buffer (a count of
the number of characters in the buffer):

#+begin_src emacs-lisp
  (buffer-size) ; 32086
#+end_src

In Emacs, the current position of the cursor is called “point”.  The expression
‘(point)’ returns an integer corresponding to the number of characters from the
beginning of the buffer to point:

#+begin_src emacs-lisp
  (point) ; 17635
#+end_src

The function ‘point-min’ returns the value of the minimum value of point in the
current buffer (which should be one unless “narrowing” is in effect).  Likewise,
the function ‘point-max’ returns the value of the maximum permissible value of
point in the current buffer.

** Exercise
Find a file with which you are working and move towards its middle.  Find its
buffer name, file name, length, and your position in the file.

#+begin_src emacs-lisp
  (switch-to-buffer (current-buffer)) ; switch to this file
  (goto-char (/ (buffer-size) 2))     ; move to its middle
  (buffer-name) ; return the name of the buffer
  (buffer-size) ; return the size (number of characters) of the buffer
  (point)       ; return the position of the point in the file
#+end_src

* How to Write Function Definitions
A symbol that has a function definition is called a function (technically, the
the definition is the function and symbol /refers/ to it).

** Primitive Functions
All functions are defined in terms of other functions, except for “primitive”
functions that are written in the C programming language.  Function definitions
are written in Emacs Lisp and use other functions a their building blocks.

** defun
A function definition has up to five parts following the symbol ‘defun’:

1. The name of the symbol to which the function definition is attached.

2. A list of the arguments that will be passed to the function.  If no arguments
   will be passed to the function, this is the empty list, ‘()’.

3. Documentation describing the function.  Although technically optional, this
   is strongly recommended.

4. Optionally, an expression to make the function interactive so that it can be
   used by typing ‘M-x’ and then the name of the function; or by typing an
   appropriate key or keychord.

5. The code that instructs the computer what to do: the “body” of the function
   definition.

The template of a function definition looks like this:

#+begin_src emacs-lisp
  (defun FUNCTION-NAME (ARGUMENTS...)
    "OPTIONAL-DOCUMENTATION..."
    (interactive ARGUMENT-PASSING-INFO) ; optional
    BODY...)
#+end_src

Here is an example of a function that multiplies its argument by seven:

#+begin_src emacs-lisp
  (defun multiply-by-seven (number)
    "Multiply NUMBER by seven."
    (* 7 number))
#+end_src

** Install a Function Definition
The process of evaluating a function definition (by running the
‘eval-last-sexp’, or typing ‘C-x C-e’ with the cursor immediately after the
definition) results in the installation of the function in Emacs’ namespace
(returning the name of the function itself).  The function can now be called
from within any expression.

*** Effect of Installation
Installing a function makes it available for use within Emacs.  The following
can now be evaluated:

#+begin_src emacs-lisp
  (multiply-by-seven 3) ; 21
#+end_src

#+RESULTS:
: 21

The documentation of a function definition can be inquired by invoking the
‘describe-function’ (‘C-h f’) command.

*** Change a Function Definition
To change or update a function definition, install the modified function
definition.  This will replace the former version in the namespace:

#+begin_src emacs-lisp
  (defun multiply-by-seven (number)     ; Second version
    "Multiply NUMBER by seven."
    (+ number number number number number number number))
#+end_src

Note that, in Lisp, everything that follows a semicolon in a line is a comment.

** Make a Function Interactive
A function is made interactive by placing a list that begins with the special
form ‘interactive’ immediately after the documentation.  A user can invoke an
interactive function by typing ‘M-x’ and then the name of the function; or by
typing the keys to which it is bound, for example, by typing ‘C-n’ for
‘next-line’ or ‘C-x h’ for ‘mark-whole-buffer’.

*** Interactive multiply-by-seven
Here is an example of an interactive version of ‘multiply-by-seven’:

#+begin_src emacs-lisp
  (defun multiply-by-seven (number)     ; Interactive version
    "Multiply NUMBER by seven."
    (interactive "p")
    (message "The result is %d" (* 7 number)))
#+end_src

Once installed, the function can now be used interactively by typing ‘C-u’ and a
number and then typing ‘M-x multiply-by-seven’ and pressing <RET>.  ‘The phrase
The result is …’ followed by the product will appear in the echo area.

An interactive function is invoked in one of two ways:

1. By typing a prefix argument that contains the number to be passed, and then
   typing ‘M-x’ and the name of the function, as with ‘C-u 3 M-x
   forward-sentence’; or,

2. By typing whatever key or keychord the function is bound to, as with ‘C-u 3
   M-e’.

Both the examples above work identically to move point forward three sentences.

A “prefix argument” is passed to an interactive function by typing the <META>
key followed by a number, for example, ‘M-3 M-e’, or by typing ‘C-u’ and then a
number, for example, ‘C-u 3 M-e’ (if you type ‘C-u’ without a number, it
defaults to 4).

*** multiply-by-seven in detail
In this function, the expression, ‘(interactive "p")’, is a list of two
elements.  The ‘"p"’ tells Emacs to pass the prefix argument to the function and
use its value for the argument of the function.

** Different Options for ‘Interactive’
Consider the function ‘zap-to-char’.  Its interactive expression is (or /was/,
at the time of the writing of the book):

#+begin_src emacs-lisp
  (interactive "p\ncZap to char: ")
#+end_src

The first part of the argument to ‘interactive’ is ‘p’, which tells Emacs to
interpret a prefix as a number to be passed to the function.  In the context of
‘zap-to-char’, the prefix is the number of specified characters to delete up
to.  Thus, if the prefix is three and the specified character is ‘x’, then the
call to the function will delete all the text up to and include the third next
‘x’.  Without a prefix, the functions deletes all the text up to and including
the specified character, but no more.

The ‘c’ tells the function the name of the character to which to delete.

The ‘interactive’ declaration is a special form of ‘C source code’ that
specifies a way of parsing arguments for interactive use of a function.  The
argument of ‘interactive’ is a string containing a code letter followed
optionally by a prompt.  To pass several arguments to the command, concatenate
the individual strings, separating them by newline characters.

Code letters available are:
+ a -- Function name: symbol with a function definition.
+ b -- Name of existing buffer.
+ B -- Name of buffer, possibly nonexistent.
+ c -- Character (no input method is used).
+ C -- Command name: symbol with interactive function definition.
+ d -- Value of point as number.  Does not do I/O.
+ D -- Directory name.
+ e -- Parameterized event (i.e., one that’s a list) that invoked this command.
  If used more than once, the Nth ‘e’ returns the Nth parameterized event.
  This skips events that are integers or symbols.
+ f -- Existing file name.
+ F -- Possibly nonexistent file name.
+ G -- Possibly nonexistent file name, defaulting to just directory name.
+ i -- Ignored, i.e. always nil.  Does not do I/O.
+ k -- Key sequence (downcase the last event if needed to get a definition).
+ K -- Key sequence to be redefined (do not downcase the last event).
+ m -- Value of mark as number.  Does not do I/O.
+ M -- Any string.  Inherits the current input method.
+ n -- Number read using minibuffer.
+ N -- Numeric prefix arg, or if none, do like code ‘n’.
+ p -- Prefix arg converted to number.  Does not do I/O.
+ P -- Prefix arg in raw form.  Does not do I/O.
+ r -- Region: point and mark as 2 numeric args, smallest first.  Does no I/O.
+ s -- Any string.  Does not inherit the current input method.
+ S -- Any symbol.
+ U -- Mouse up event discarded by a previous k or K argument.
+ v -- Variable name: symbol that is ‘custom-variable-p’.
+ x -- Lisp expression read but not evaluated.
+ X -- Lisp expression read and evaluated.
+ z -- Coding system.
+ Z -- Coding system, nil if no prefix arg.

** Install Code Permanently
Functions installed through evaluation are purged from memory upon quitting
Emacs.  In order to have code installed automatically whenever Emacs is started,
one needs to:

+ Write code into the ‘.emacs’ initialization file.  This file is automatically
  evaluated when Emacs is started and all the functions within it are installed.

+ Functions can also be written into one or more files of their own and then
  loaded via the ‘load’ function.  This causes Emacs to evaluate and thereby
  install each of the functions in the files.

+ For code that an entire site will use, it is customary to write it into a file
  called ‘site-init.el’ that is loaded when Emacs is built.  This makes the code
  available for everyone using that machine.

** let
The ‘let’ expression is a special form in Lisp that is used in most function
definitions.  ‘let’ is used to attach or bind a symbol within the scope of a function.

*** Prevent confusion
‘let’ creates a name for a “local variable” that overshadows any use of the same
name outside the ‘let’ expression.

Local variables created by a ‘let’ expression retain their value /only/ within
the ‘let’ expression itself (and within expressions called within the ‘let’
expression); the local variables have no effect outside the ‘let’ expression.

‘let’ is like a ‘setq’ that is temporary and local.  The values set by ‘let’ are
automatically undone when the ‘let’ is finished.  In Emacs Lisp, scoping is
dynamic, not lexical.

From the [[https://www.wikiwand.com/en/Scope_(computer_science)#/Lexical_scope_vs._dynamic_scope][Wikipedia]] entry on lexical scope vs. dynamic scope:

#+begin_quote
In languages with lexical scope (also called static scope), name resolution
depends on the location in the source code and the lexical context, which is
defined by where the named variable or function is defined.  In contrast, in
languages with dynamic scope the name resolution depends upon the program state
when the name is encountered which is determined by the execution context or
calling context.  In practice, with lexical scope a variable’s definition is
resolved by searching its containing block or function, then if that fails
searching the outer containing block, and so on, whereas with dynamic scope the
calling function is searched, then the function which called that calling
function, and so on, progressing up the call stack.
#+end_quote

*** Parts of let expression
A ‘let’ expression is a list of three parts.  This first part is the symbol
‘let’.  The second part is a list, called a “varlist”, each element of which is
either a symbol by itself or a two-element list, the first element of which is a
symbol.  The third part of the ‘let’ expression consists of one or more lists.

The following is a template for a ‘let’  expression:

#+begin_src emacs-lisp
  (let VARLIST BODY...)
#+end_src

The symbols in the varlist are the variables that are given initial values by
the ‘let’ special form.  Symbols by themselves are given the initial value of
‘nil’; and each symbol that is the first element of a two-element list is bound
to the value that is returned when the Lisp interpreter evaluates the second
element.

Thus, a varlist might look like this: ‘(thread (needles 3))’.  In this case, in
a ‘let’ expression, Emacs binds the symbol ‘thread’ to an initial value of
‘nil’, and binds the symbol ‘needles’ to an initial value of 3.

*** Sample let Expression
The following expression creates and gives initial values to the two variables
‘zebra’ and ‘tiger’.  The body of the ‘let’ expression is a list which calls the
‘message’ function:

#+begin_src emacs-lisp
  (let ((zebra "stripes")
        (tiger "fierce"))
    (message "One kind of animal has %s and another is %s."
             zebra tiger))
#+end_src

#+RESULTS:
: One kind of animal has stripes and another is fierce.

*** Uninitialized let Variables
If you do not bind the variables of a ‘let’ statement to specific initial
values, they will automatically be bound to an initial value of ‘nil’, as in the
following expression:

#+begin_src emacs-lisp
  (let ((birch 3)
        pine
        fir
        (oak 'some))
    (message
     "Here are %d variables with %s, %s, and %s value."
     birch pine fir oak))
#+end_src

#+RESULTS:
: Here are 3 variables with nil, nil, and some value.

** if
A third special form, in addition to ‘defun’ and ‘let’, is the conditional ‘if’.
This form is used to instruct the computer to make decisions.

*** if in more detail
An ‘if’ expression written in Lisp does not use the word “then”; the test and
the action are the second and third elements of the list whose first element is
‘if’.  Nonetheless, the test part of an ‘if’ expression is often called the
“if-part” and the second argument is often called the “then-part”.

Also, when an ‘if’ expression is written, the true-or-false-test is usually
written on the same line as the symbol ‘if’, but the action to carry out if the
test is true, the then-part, is written on the second and subsequent lines.
This makes the ‘if’ expression easier to read:

#+begin_src emacs-lisp
  (if TRUE-OR-FALSE-TEST
      ACTION-TO-CARRY-OUT-IF-TEST-IS-TRUE)
#+end_src

Here is an example:

#+begin_src emacs-lisp
  (if (> 5 4)                           ; if-part
  (message "Five is greater than four!")) ; then-part
#+end_src

#+RESULTS:
: Five is greater than four!

And a more realistic example:

#+begin_src emacs-lisp
  (defun type-of-animal (characteristic)
    "Print message in echo area depending on CHARACTERISTIC.
  If the CHARACTERISTIC is the string \"fierce\",
 then warn of a tiger."
    (if (equal characteristic "fierce")
        (message "It is a tiger!")))

  (type-of-animal "fierce")"It is a tiger!"
  (type-of-animal "striped")
#+end_src

*** type-of-animal in detail
‘if’ is a special form in ‘C source code’.

The template of and ‘if’ statement is:

#+begin_src emacs-lisp
  (if COND THEN ELSE...)
#+end_src

If COND yields non-nil, do THEN, else do ELSE...
Returns the value of THEN or the value of the last of the ELSE’s.
THEN must be one expression, but ELSE... can be zero or more expressions.
If COND yields nil, and there are no ELSE’s, the value is nil.

** else
An ‘if’ expression may have an optional third argument, called the “else-part”,
for the case when the true-or-false-test returns false.  When this happens, the
second argument or then-part of the overall ‘if’ expression is /not/ evaluated,
but the third or else-part /is/ evaluated.

In the written Lisp, the else-part is usually written to start on a line of its
own and is indented less than the then-part:

#+begin_src emacs-lisp
  (if TRUE-OR-FALSE-TEST
         ACTION-TO-CARRY-OUT-IF-THE-TEST-RETURNS-TRUE
       ACTION-TO-CARRY-OUT-IF-THE-TEST-RETURNS-FALSE)
#+end_src

Here is an example:

#+begin_src emacs-lisp
  (if (> 4 5)                        ; if-part
      (message "Four falsely greater than five!") ; then-part
      (message "Four is not greater than five!"))   ; else-part
#+end_src

#+RESULTS:
: Four is not greater than five!

And a more elaborated example with the ‘type-of-animal’ function:

#+begin_src emacs-lisp
  (defun type-of-animal (characteristic)  ; Second version.
    "Print message in echo area depending on CHARACTERISTIC.
  If the CHARACTERISTIC is the string \"fierce\",
  then warn of a tiger; else say it is not fierce."
    (if (equal characteristic "fierce")
        (message "It is a tiger!")
      (message "It is not fierce!")))

  (type-of-animal "fierce")"It is a tiger!"
  (type-of-animal "striped")"It is not fierce!"
#+end_src

** Truth & Falsehood
In Lisp, the predicate “false” is represented by the symbol ‘nil’.  Anything
else (anything at all) is “true”.

The expression that tests for truth is interpreted as “true” if the result of
evaluating it is a value that is not ‘nil’.  In other words, the result of the
test is considered true if the value returned is a number such as 42, a string
such as ‘"hello"’, or a symbol (other than ‘nil’) such as ‘flowers’, or a list
(so long as it is not empty), or even a buffer.  If some other useful value is
not available for the test that returns true, then the Lisp interpreter will
return the symbol ‘t’ for true (see example under the following headline).

*** nil explained
In Emacs Lisp, the symbol ‘nil’ has two meanings.  First, it means the empty
list.  Second, it means false and is the value returned when a
true-or-false-test tests false.  ‘nil’ can be written as an empty list, ‘()’, or
as ‘nil’.  As far as the Lisp interpreter is concerned, ‘()’ and ‘nil’ are the
same:

#+begin_src emacs-lisp
  (equal () nil)
#+end_src

#+RESULTS:
: t

** save-excursion
The ‘save-excursion’ function is a special form that saves the location of the
point, executes the body of the function, and then restores point to its
previous position if its location has changed.

*** Point and mark
“Point” is the current location of the cursor.  More precisely, on terminals
where the cursor appears to be on top of a character, point is the immediately
before the character.  In Emacs Lisp, point is an integer.  The function ‘point’
returns the current position of the cursor as a number.  Each buffer has its own
value for point.

The “mark” is another position in the buffer; its value can be set with a
command such as ‘set-mark-command’ (‘C-<SPC>’).  If a mark has been set, the
command ‘exchange-point-and-mark’ (‘C-x C-x’) causes the cursor to jump to the
mark and set the mark to be the previous position of point.  In addition,
setting another mark saves the position of the previous mark in the mark ring.
Many mark positions can be saved this way.  The prefixed command ‘C-u C-<SPC>’
will jump to mark, and set the mark from position popped off the local mark
ring.  Thus, successive invocations of ‘C-u C-<SPC>’ will sequentially jump to
each previous positions of the mark kept in the mark ring.

The part of the buffer between point and mark is called “the region”.  Numerous
commands work on the region, including ‘center-region’, ‘count-lines-region’,
‘kill-region’, and ‘print-region’.

The ‘save-excursion’ special form saves the location of point and restores this
position after the cod ewithin the body of the special form is evaluated by the
Lisp interpreter.

*** Template for save-excursion
The template for save-excursion is as follows:

#+begin_src emacs-lisp
  (save-excursion
    BODY...)
#+end_src

The body of the function is one or more expressions that will be evaluated in
sequence by the Lisp interpreter.  If there is more than one expression in the
body, the value of the last one will be returned as the value of the
‘save-excursion’ function.  The other expressions in the body are evaluated only
for their side effects; and ‘save-excursion’ itself is used only for its side
effect (which is restoring the position of point).

In Emacs Lisp code, a ‘save-excursion’ expression often occurs within the body
of a ‘let’ expression:

#+begin_src emacs-lisp
  (let VARLIST
    (save-excursion
      BODY...))
#+end_src

** Review
* Buffer Walk Through
* More Complex
* Narrowing & Widening
* car cdr & cons
* Cutting & Storing Text
* List Implementation
* Yanking
* Loops & Recursion
* Regexp Search
* Counting Words
* Words in a defun
* Readying a Graph
* Emacs Initialization
* Debugging
* Conclusion
* the-the
* Kill Ring
* Full Graph
* Free Software and Free Manuals
* GNU Free Documentation License
